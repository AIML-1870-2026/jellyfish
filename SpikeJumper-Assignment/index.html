<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Rainbow Runners</title>
<link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #0a0814;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  font-family: 'Nunito', sans-serif;
  overflow: hidden;
}
#titleScreen {
  position: absolute;
  top: 0; left: 0;
  width: 100vw;
  height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, #0a0814 0%, #12082a 50%, #0a1020 100%);
  z-index: 10;
}
.title-inner {
  display: flex;
  gap: 40px;
  max-width: 1140px;
  width: 100%;
  padding: 20px;
}
.title-left {
  flex: 1.1;
  color: #e8e0ff;
  display: flex;
  flex-direction: column;
  gap: 18px;
}
.game-title {
  font-family: 'Fredoka One', cursive;
  font-size: 3.2rem;
  background: linear-gradient(90deg, #ff6b6b, #ffd700, #7fff00, #00cfff, #9b59ff);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  line-height: 1.1;
  text-shadow: none;
  filter: drop-shadow(0 0 20px rgba(155,89,255,0.4));
}
.panel {
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 14px;
  padding: 14px 18px;
}
.panel h3 {
  font-family: 'Fredoka One', cursive;
  font-size: 1.05rem;
  color: #ffd700;
  margin-bottom: 8px;
}
.panel p, .panel li {
  font-size: 0.82rem;
  color: #c8c0e0;
  line-height: 1.5;
}
.panel ul { list-style: none; }
.panel ul li { padding: 2px 0; }
.zone-row { display: flex; align-items: center; gap: 8px; margin: 3px 0; font-size: 0.8rem; }
.zone-icon { font-size: 1rem; }
.title-right {
  flex: 0.9;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 16px;
}
.chooser-title {
  font-family: 'Fredoka One', cursive;
  font-size: 1.4rem;
  color: #ffd700;
}
.pony-grid {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 10px;
  width: 100%;
}
.pony-card {
  background: rgba(255,255,255,0.06);
  border: 2px solid rgba(255,255,255,0.15);
  border-radius: 12px;
  padding: 10px;
  cursor: pointer;
  text-align: center;
  transition: all 0.2s;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
}
.pony-card:hover { background: rgba(255,255,255,0.12); transform: translateY(-2px); }
.pony-card.selected {
  border-color: #ffd700;
  background: rgba(255,215,0,0.12);
  box-shadow: 0 0 16px rgba(255,215,0,0.3);
}
.pony-card canvas { border-radius: 8px; }
.pony-name {
  font-family: 'Fredoka One', cursive;
  font-size: 0.85rem;
  color: #e8e0ff;
}
.start-btn {
  font-family: 'Fredoka One', cursive;
  font-size: 1.4rem;
  padding: 14px 44px;
  border: none;
  border-radius: 50px;
  cursor: pointer;
  background: linear-gradient(90deg, #ff6b6b, #ffd700, #7fff00, #00cfff, #9b59ff, #ff6b6b);
  background-size: 200% auto;
  color: #1a0a2e;
  animation: rainbowShift 3s linear infinite;
  box-shadow: 0 4px 24px rgba(155,89,255,0.4);
  transition: transform 0.15s;
}
.start-btn:hover { transform: scale(1.06); }
@keyframes rainbowShift { to { background-position: 200% center; } }

#gameCanvas {
  display: none;
  border-radius: 8px;
  box-shadow: 0 0 60px rgba(100,50,255,0.3);
}
</style>
</head>
<body>

<div id="titleScreen">
  <div class="title-inner">
    <div class="title-left">
      <div class="game-title">Rainbow Runners</div>
      <div class="panel">
        <h3>âœ¨ A World Without Color</h3>
        <p>A mysterious shadow has drained all color from the land, leaving only cold grey silence. You are a magical pony â€” and everywhere you run, your rainbow trail restores life, light, and color to the world. The faster you run, the more vibrant the world becomes.</p>
      </div>
      <div class="panel">
        <h3>ğŸ—º The Journey</h3>
        <div class="zone-row"><span class="zone-icon">ğŸ</span><span><b>Apple Orchard</b> â€” Golden sun, warm greens, ripe apples</span></div>
        <div class="zone-row"><span class="zone-icon">ğŸŒ‘</span><span><b>Spooky Forest</b> â€” Dead trees, pale moon, swooping bats</span></div>
        <div class="zone-row"><span class="zone-icon">ğŸ°</span><span><b>Castle Fields</b> â€” Rolling hills, grand castle, twilight blue</span></div>
        <div class="zone-row"><span class="zone-icon">ğŸ’</span><span><b>Crystal Caves</b> â€” Indigo depths, dense glowing crystals</span></div>
      </div>
      <div class="panel">
        <h3>ğŸ® How to Play</h3>
        <ul>
          <li>â¬† <b>Space / Click / Tap</b> â€” Jump (up to 3 times!)</li>
          <li>ğŸŒˆ <b>Rainbow Circle</b> â€” Speed boost + unlimited jumps for 5s</li>
          <li>ğŸ›¡ <b>Shield</b> â€” 7 seconds of invincibility</li>
          <li>ğŸŒ¿ Dodge the thorny bushes â€” they're the only hazard</li>
          <li>ğŸªµ Land on floating platforms to reset your jumps</li>
        </ul>
      </div>
    </div>
    <div class="title-right">
      <div class="chooser-title">Choose Your Pony</div>
      <div class="pony-grid" id="ponyGrid"></div>
      <button class="start-btn" id="startBtn">Let's Run! ğŸŒˆ</button>
    </div>
  </div>
</div>

<canvas id="gameCanvas" width="1100" height="620"></canvas>

<script>
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  CONSTANTS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const W = 1100, H = 620;
const GROUND_Y = 510;
const PONY_X = 160;
const GRAVITY = 0.55;
const JUMP_FORCE = -13.5;
const MAX_JUMPS = 3;
const CYCLE_DIST = 5300;

const ZONES = [
  { name: "ğŸ APPLE ORCHARD",  start: 0,    skyTop: '#1a3a08', skyBot: '#2a5010', ground: '#3a5a18' },
  { name: "ğŸŒ‘ SPOOKY FOREST",  start: 900,  skyTop: '#0a0820', skyBot: '#180830', ground: '#1a1018' },
  { name: "ğŸ° CASTLE FIELDS",  start: 2200, skyTop: '#082040', skyBot: '#103060', ground: '#204030' },
  { name: "ğŸ’ CRYSTAL CAVES",  start: 3800, skyTop: '#080520', skyBot: '#100a30', ground: '#141028' },
];
const GREY_SKY_TOP = '#1a1a22', GREY_SKY_BOT = '#252530', GREY_GROUND = '#2a2a32';

const PONIES = [
  { name: 'Twilight',   body: '#7b3f9e', mane: '#4a1878', tail: '#4a1878', inner: '#c090f0' },
  { name: 'Pinkie',     body: '#f06fa0', mane: '#d03060', tail: '#d03060', inner: '#ffc0d8' },
  { name: 'Fluttershy', body: '#f8f0b0', mane: '#f0a0b8', tail: '#f0a0b8', inner: '#fff8d0' },
  { name: 'Applejack',  body: '#e8a832', mane: '#c04820', tail: '#c04820', inner: '#ffe090' },
  { name: 'Rainbow',    body: '#60b0ff', mane: '#ff4400', tail: '#ff4400', inner: '#c0e8ff' },
  { name: 'Rarity',     body: '#f0ecff', mane: '#8844cc', tail: '#8844cc', inner: '#ffffff' },
];

const RAINBOW_COLORS = ['#ff0000','#ff7700','#ffee00','#00cc44','#0088ff','#9900ff'];

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  AUDIO
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let audioCtx = null;
function getAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}
function playJump() {
  try {
    const ctx = getAudio();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain); gain.connect(ctx.destination);
    osc.frequency.setValueAtTime(280, ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(560, ctx.currentTime + 0.22);
    gain.gain.setValueAtTime(0.18, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.22);
    osc.start(); osc.stop(ctx.currentTime + 0.22);
  } catch(e){}
}
function playRainbowPickup() {
  try {
    const ctx = getAudio();
    const freqs = [300, 500, 700, 900, 1100, 1400];
    freqs.forEach((f, i) => {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.connect(gain); gain.connect(ctx.destination);
      osc.type = 'sine';
      osc.frequency.value = f;
      const t = ctx.currentTime + i * 0.07;
      gain.gain.setValueAtTime(0.15, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.18);
      osc.start(t); osc.stop(t + 0.2);
    });
  } catch(e){}
}
function playShieldPickup() {
  try {
    const ctx = getAudio();
    [500, 750, 600, 900].forEach((f, i) => {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.connect(gain); gain.connect(ctx.destination);
      osc.type = 'sine'; osc.frequency.value = f;
      const t = ctx.currentTime + i * 0.09;
      gain.gain.setValueAtTime(0.12, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
      osc.start(t); osc.stop(t + 0.18);
    });
  } catch(e){}
}
function playDeath() {
  try {
    const ctx = getAudio();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.connect(gain); gain.connect(ctx.destination);
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(350, ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(70, ctx.currentTime + 0.7);
    gain.gain.setValueAtTime(0.2, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.7);
    osc.start(); osc.stop(ctx.currentTime + 0.7);
  } catch(e){}
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  UTILITY
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function lerp(a, b, t) { return a + (b - a) * t; }
function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
function randBetween(a, b) { return a + Math.random() * (b - a); }
function randInt(a, b) { return Math.floor(randBetween(a, b + 1)); }

function hexToRgb(hex) {
  const r = parseInt(hex.slice(1,3),16);
  const g = parseInt(hex.slice(3,5),16);
  const b = parseInt(hex.slice(5,7),16);
  return [r,g,b];
}
function rgbToGrey(r,g,b) {
  const v = Math.round(0.299*r + 0.587*g + 0.114*b);
  return `rgb(${v},${v},${v})`;
}
function lerpColor(hexA, hexB, t) {
  const [ar,ag,ab] = hexToRgb(hexA);
  const [br,bg,bb] = hexToRgb(hexB);
  const r = Math.round(lerp(ar,br,t));
  const g = Math.round(lerp(ag,bg,t));
  const b_c = Math.round(lerp(ab,bb,t));
  return `rgb(${r},${g},${b_c})`;
}
function greyOf(hex) {
  const [r,g,b] = hexToRgb(hex);
  return rgbToGrey(r,g,b);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  PONY DRAWING
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawPonyPortrait(ctx, pony, x, y, scale, time, isDead, isRainbow) {
  ctx.save();
  ctx.translate(x, y);
  ctx.scale(scale, scale);

  const legSwing = isDead ? 0 : Math.sin(time * 11) * 6;
  const bodyColor = isDead ? greyOf(pony.body) : pony.body;
  const maneColor = isDead ? '#555' : pony.mane;
  const innerColor = isDead ? '#888' : pony.inner;

  // Shadow
  ctx.save();
  ctx.globalAlpha = 0.25;
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.ellipse(0, 26, 28, 7, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // Legs
  const legPairs = [[-14, 14], [6, 30]];
  legPairs.forEach(([lx, rx]) => {
    const swing1 = legSwing * (lx < 0 ? 1 : -1);
    const swing2 = -swing1;
    ctx.fillStyle = bodyColor;
    ctx.save();
    ctx.translate(lx, 14);
    ctx.rotate(swing1 * Math.PI / 180);
    ctx.beginPath();
    ctx.roundRect(-4, 0, 8, 18, 3);
    ctx.fill();
    ctx.restore();
    ctx.save();
    ctx.translate(rx, 14);
    ctx.rotate(swing2 * Math.PI / 180);
    ctx.beginPath();
    ctx.roundRect(-4, 0, 8, 18, 3);
    ctx.fill();
    ctx.restore();
  });

  // Body
  ctx.fillStyle = bodyColor;
  ctx.beginPath();
  ctx.roundRect(-28, -14, 56, 32, 12);
  ctx.fill();

  // Head
  ctx.fillStyle = bodyColor;
  ctx.beginPath();
  ctx.roundRect(-44, -28, 28, 26, 10);
  ctx.fill();

  // Snout
  ctx.fillStyle = innerColor;
  ctx.beginPath();
  ctx.ellipse(-48, -16, 9, 7, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.fillStyle = isDead ? '#666' : '#c87060';
  ctx.beginPath();
  ctx.ellipse(-50, -17, 2, 1.5, -0.3, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(-45, -17, 2, 1.5, 0.3, 0, Math.PI*2);
  ctx.fill();

  // Eye
  if (isDead) {
    ctx.strokeStyle = '#cc0000';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(-39, -22); ctx.lineTo(-35, -18); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(-35, -22); ctx.lineTo(-39, -18); ctx.stroke();
    // Tear
    ctx.fillStyle = '#88bbff';
    ctx.beginPath(); ctx.ellipse(-40, -14, 2, 4, 0, 0, Math.PI*2); ctx.fill();
  } else {
    ctx.fillStyle = '#1a0a30';
    ctx.beginPath(); ctx.ellipse(-38, -20, 5, 5.5, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.ellipse(-36, -22, 1.5, 1.5, 0, 0, Math.PI*2); ctx.fill();
    // Lashes
    ctx.strokeStyle = '#1a0a30'; ctx.lineWidth = 1.2;
    [[-42,-24],[-40,-25],[-38,-25],[-35,-24]].forEach(([ex,ey]) => {
      ctx.beginPath(); ctx.moveTo(ex+2, -18); ctx.lineTo(ex, ey); ctx.stroke();
    });
  }

  // Ear
  const earTip = isDead ? -5 : -2;
  ctx.fillStyle = bodyColor;
  ctx.beginPath();
  ctx.moveTo(-36, -26); ctx.lineTo(-28, -36 + (isDead ? 8 : 0)); ctx.lineTo(-22, -26);
  ctx.fill();
  ctx.fillStyle = innerColor;
  ctx.beginPath();
  ctx.moveTo(-34, -26); ctx.lineTo(-28, -32 + (isDead ? 6 : 0)); ctx.lineTo(-24, -26);
  ctx.fill();

  // Mane / tail
  if (isRainbow && !isDead) {
    RAINBOW_COLORS.forEach((rc, ri) => {
      const off = ri * 2.5;
      // Mane
      ctx.strokeStyle = rc; ctx.lineWidth = 3; ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(-26 + Math.sin(time*3+ri)*2, -30);
      ctx.bezierCurveTo(-10+off, -42+Math.sin(time*4+ri)*3, 10+off, -30, 14+off, -8+Math.sin(time*5+ri)*3);
      ctx.stroke();
      // Tail
      ctx.beginPath();
      ctx.moveTo(28, 0 + ri*2);
      ctx.bezierCurveTo(40+off, 8+Math.sin(time*4+ri*1.3)*3, 46+off, 20, 44+off, 32+Math.sin(time*3+ri)*4);
      ctx.stroke();
    });
  } else {
    ctx.strokeStyle = maneColor; ctx.lineWidth = 6; ctx.lineCap = 'round';
    // Mane strand 1
    ctx.beginPath();
    ctx.moveTo(-26, -28);
    ctx.bezierCurveTo(-8, -40, 10, -28, 14, -6);
    ctx.stroke();
    // Mane strand 2
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(-22, -26);
    ctx.bezierCurveTo(-4, -44, 16, -30, 18, -4);
    ctx.stroke();
    // Tail
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.moveTo(28, 2);
    ctx.bezierCurveTo(40, 10, 46, 24, 44, 36);
    ctx.stroke();
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(28, 6);
    ctx.bezierCurveTo(44, 14, 48, 28, 46, 38);
    ctx.stroke();
  }

  ctx.restore();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  TITLE SCREEN â€” PONY GRID
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let selectedPony = 0;
function buildPonyGrid() {
  const grid = document.getElementById('ponyGrid');
  grid.innerHTML = '';
  PONIES.forEach((pony, i) => {
    const card = document.createElement('div');
    card.className = 'pony-card' + (i === selectedPony ? ' selected' : '');
    const cvs = document.createElement('canvas');
    cvs.width = 90; cvs.height = 80;
    const ctx2 = cvs.getContext('2d');
    // Dark bg
    ctx2.fillStyle = '#12082a';
    ctx2.fillRect(0, 0, 90, 80);
    drawPonyPortrait(ctx2, pony, 50, 58, 0.9, 0, false, false);
    const nameEl = document.createElement('div');
    nameEl.className = 'pony-name';
    nameEl.textContent = pony.name;
    card.appendChild(cvs);
    card.appendChild(nameEl);
    card.addEventListener('click', () => {
      selectedPony = i;
      document.querySelectorAll('.pony-card').forEach((c, ci) => {
        c.classList.toggle('selected', ci === i);
      });
    });
    grid.appendChild(card);
  });
}
buildPonyGrid();

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  GAME STATE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let gameState = 'title'; // 'title' | 'playing' | 'dead'
let scrollX = 0;
let distance = 0;
let gameSpeed = 6;
let time = 0;
let shake = 0;

// Pony
let ponyY = GROUND_Y - 40;
let ponyVY = 0;
let jumpsLeft = MAX_JUMPS;
let isDead = false;
let deathTimer = 0;
let overlayAlpha = 0;
let rainbowMode = 0; // frames remaining
let shieldTimer = 0;

// Entities
let obstacles = [];
let platforms = [];
let powerups = [];
let particles = [];
let trailPoints = [];

// Spawn timers
let obstacleTimer = 80;
let platformTimer = 150;
let powerupTimer = 250;

// Background objects (seeded procedurally)
let bgObjects = [];

// HUD
let zoneLabel = ZONES[0].name;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  BACKGROUND GENERATION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildBgObjects() {
  bgObjects = [];
  const TOTAL = CYCLE_DIST;

  // ZONE 0: Apple Orchard â€” apple trees + sun
  for (let wx = 200; wx < 900; wx += 280 + Math.random()*120) {
    bgObjects.push({ type:'appleTree', wx, depth: 0.3 + Math.random()*0.15 });
  }
  bgObjects.push({ type:'sun', wx: 400, depth: 0.05 });

  // ZONE 1: Spooky Forest â€” dead trees, bats, moon
  for (let wx = 950; wx < 2150; wx += 180 + Math.random()*100) {
    bgObjects.push({ type:'deadTree', wx, depth: 0.25 + Math.random()*0.2 });
  }
  bgObjects.push({ type:'moon', wx: 1400, depth: 0.05 });
  for (let wx = 1050; wx < 2100; wx += 220 + Math.random()*80) {
    bgObjects.push({ type:'bat', wx, depth: 0.7 + Math.random()*0.15 });
  }

  // ZONE 2: Castle Fields â€” hills, castle
  for (let wx = 2300; wx < 3750; wx += 350 + Math.random()*150) {
    bgObjects.push({ type:'hill', wx, depth: 0.1 + Math.random()*0.1, size: 0.8 + Math.random()*0.5 });
  }
  bgObjects.push({ type:'castle', wx: 3000, depth: 0.08 });

  // ZONE 3: Crystal Caves â€” crystals
  for (let wx = 3850; wx < 5250; wx += 90 + Math.random()*40) {
    bgObjects.push({ type:'crystal', wx, depth: 0.1 + Math.random()*0.55, size: 0.5 + Math.random()*1.2, color: RAINBOW_COLORS[Math.floor(Math.random()*6)] });
  }
  for (let wx = 3870; wx < 5250; wx += 240 + Math.random()*80) {
    bgObjects.push({ type:'crystal', wx, depth: 0.6 + Math.random()*0.3, size: 1.0 + Math.random()*1.5, color: RAINBOW_COLORS[Math.floor(Math.random()*6)] });
  }
  for (let wx = 3900; wx < 5250; wx += 130 + Math.random()*60) {
    bgObjects.push({ type:'crystal', wx, depth: 0.05 + Math.random()*0.08, size: 0.3 + Math.random()*0.5, color: '#8888ff' });
  }
  // Stalactites
  for (let wx = 3860; wx < 5250; wx += 110 + Math.random()*70) {
    bgObjects.push({ type:'stalactite', wx, depth: 0.2 + Math.random()*0.4, size: 0.6 + Math.random()*1.2 });
  }
}
buildBgObjects();

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  ZONE HELPERS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getZoneProgress(dist) {
  const d = dist % CYCLE_DIST;
  let zi = 0;
  for (let i = ZONES.length - 1; i >= 0; i--) {
    if (d >= ZONES[i].start) { zi = i; break; }
  }
  const nextZi = (zi + 1) % ZONES.length;
  const zStart = ZONES[zi].start;
  const zEnd = nextZi === 0 ? CYCLE_DIST : ZONES[nextZi].start;
  const subT = clamp((d - zStart) / (zEnd - zStart), 0, 1);
  return { zi, nextZi, subT };
}

function getZoneColors(dist) {
  const { zi, nextZi, subT } = getZoneProgress(dist);
  const curr = ZONES[zi], next = ZONES[nextZi];
  return {
    skyTop: lerpColor(curr.skyTop, next.skyTop, subT),
    skyBot: lerpColor(curr.skyBot, next.skyBot, subT),
    ground: lerpColor(curr.ground, next.ground, subT),
    zi, subT
  };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  BACKGROUND DRAW
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawBackground(splitX) {
  const colors = getZoneColors(distance);
  const cyCnt = Math.floor(scrollX / CYCLE_DIST);

  // Sky - left (colored), right (grey)
  const skyGradL = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
  skyGradL.addColorStop(0, colors.skyTop);
  skyGradL.addColorStop(1, colors.skyBot);
  ctx.fillStyle = skyGradL;
  ctx.fillRect(0, 0, splitX, GROUND_Y);

  const skyGradR = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
  skyGradR.addColorStop(0, GREY_SKY_TOP);
  skyGradR.addColorStop(1, GREY_SKY_BOT);
  ctx.fillStyle = skyGradR;
  ctx.fillRect(splitX, 0, W - splitX, GROUND_Y);

  // Ground - left colored, right grey
  ctx.fillStyle = colors.ground;
  ctx.fillRect(0, GROUND_Y, splitX, H - GROUND_Y);
  ctx.fillStyle = GREY_GROUND;
  ctx.fillRect(splitX, GROUND_Y, W - splitX, H - GROUND_Y);

  // Ground line highlight
  ctx.fillStyle = 'rgba(255,255,255,0.08)';
  ctx.fillRect(0, GROUND_Y, W, 2);

  // Background objects â€” draw sorted by depth (far first)
  const sorted = [...bgObjects].sort((a, b) => a.depth - b.depth);
  for (let cycle = 0; cycle <= cyCnt + 1; cycle++) {
    const baseScroll = cycle * CYCLE_DIST;
    sorted.forEach(obj => {
      const worldX = obj.wx + baseScroll;
      const screenX = worldX - scrollX * obj.depth;
      if (screenX < -300 || screenX > W + 300) return;
      const colored = screenX < splitX;
      drawBgObject(ctx, obj, screenX, colored, colors.zi, time);
    });
  }
}

function drawBgObject(ctx, obj, sx, colored, zi, t) {
  ctx.save();
  switch (obj.type) {
    case 'sun': drawSun(ctx, sx, 80, colored); break;
    case 'moon': drawMoon(ctx, sx, 90, colored); break;
    case 'appleTree': drawAppleTree(ctx, sx, GROUND_Y, colored, obj.depth); break;
    case 'deadTree': drawDeadTree(ctx, sx, GROUND_Y, colored, obj.depth, t); break;
    case 'bat': drawBat(ctx, sx, GROUND_Y - 120 - obj.depth*80, colored, t); break;
    case 'hill': drawHill(ctx, sx, GROUND_Y, colored, obj.size); break;
    case 'castle': drawCastle(ctx, sx, GROUND_Y, colored); break;
    case 'crystal': drawCrystal(ctx, sx, GROUND_Y, colored, obj.size, obj.color, t); break;
    case 'stalactite': drawStalactite(ctx, sx, 0, colored, obj.size); break;
  }
  ctx.restore();
}

function drawSun(ctx, x, y, colored) {
  ctx.globalAlpha = 0.9;
  if (colored) {
    const g = ctx.createRadialGradient(x,y,0,x,y,60);
    g.addColorStop(0,'#ffffc0'); g.addColorStop(0.3,'#ffd700'); g.addColorStop(1,'rgba(255,200,0,0)');
    ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x,y,60,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#ffffa0'; ctx.beginPath(); ctx.arc(x,y,22,0,Math.PI*2); ctx.fill();
  } else {
    ctx.fillStyle = '#444'; ctx.beginPath(); ctx.arc(x,y,22,0,Math.PI*2); ctx.fill();
  }
}
function drawMoon(ctx, x, y, colored) {
  ctx.globalAlpha = 0.85;
  const c = colored ? '#e8e0c0' : '#444';
  ctx.fillStyle = c;
  ctx.beginPath(); ctx.arc(x,y,28,0,Math.PI*2); ctx.fill();
  if (colored) { ctx.fillStyle='#c8c090'; } else { ctx.fillStyle='#333'; }
  ctx.beginPath(); ctx.arc(x+8,y-6,22,0,Math.PI*2); ctx.fill();
}
function drawAppleTree(ctx, x, y, colored, depth) {
  const s = clamp(depth * 2, 0.4, 1.2);
  const trunkH = 60 * s, trunkW = 10 * s;
  ctx.fillStyle = colored ? '#5a3010' : '#333';
  ctx.fillRect(x - trunkW/2, y - trunkH, trunkW, trunkH);
  // Foliage
  const fc = colored ? '#2a7020' : '#333';
  [[0,-trunkH-20],[âˆ’15,-trunkH],[15,-trunkH],[-8,-trunkH+15],[8,-trunkH+15]].forEach(([dx,dy]) => {
    ctx.fillStyle = fc;
    ctx.beginPath(); ctx.arc(x+dx*s, y+dy*s, 25*s, 0, Math.PI*2); ctx.fill();
  });
  // Apples
  if (colored) {
    [[-12,-trunkH-8],[10,-trunkH-5],[-5,-trunkH+12],[14,-trunkH+8]].forEach(([dx,dy]) => {
      ctx.fillStyle = '#dd2222';
      ctx.beginPath(); ctx.arc(x+dx*s, y+dy*s, 5*s, 0, Math.PI*2); ctx.fill();
    });
  }
}
function drawDeadTree(ctx, x, y, colored, depth, t) {
  const s = clamp(depth * 2, 0.5, 1.2);
  const h = 90 * s;
  ctx.strokeStyle = colored ? '#4a3020' : '#333';
  ctx.lineWidth = 7 * s; ctx.lineCap = 'round';
  ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y - h); ctx.stroke();
  // Branches
  const branches = [[-28,-0.6],[22,-0.55],[-18,-0.75],[16,-0.7],[-12,-0.85],[10,-0.88]];
  ctx.lineWidth = 3.5 * s;
  branches.forEach(([dx, frac]) => {
    const bx = x + dx*s, by = y + frac * h;
    ctx.beginPath(); ctx.moveTo(x, by); ctx.lineTo(bx, by - 22*s); ctx.stroke();
  });
  if (colored) {
    // Eerie glow
    ctx.globalAlpha = 0.12 + Math.sin(t*1.5)*0.06;
    const g = ctx.createRadialGradient(x, y-h/2, 0, x, y-h/2, 50*s);
    g.addColorStop(0,'#88ff88'); g.addColorStop(1,'transparent');
    ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x, y-h/2, 50*s, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
  }
}
function drawBat(ctx, x, y, colored, t) {
  const flap = Math.sin(t * 8) * 0.5;
  const bc = colored ? '#2a1040' : '#333';
  ctx.fillStyle = bc;
  // Wings
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.bezierCurveTo(x-24, y-18+flap*10, x-36, y-4, x-28, y+8);
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.bezierCurveTo(x+24, y-18+flap*10, x+36, y-4, x+28, y+8);
  ctx.fill();
  // Body
  ctx.beginPath(); ctx.ellipse(x, y, 6, 7, 0, 0, Math.PI*2); ctx.fill();
  // Eyes
  if (colored) { ctx.fillStyle='#ff3300'; } else { ctx.fillStyle='#555'; }
  ctx.beginPath(); ctx.arc(x-3, y-2, 2, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x+3, y-2, 2, 0, Math.PI*2); ctx.fill();
}
function drawHill(ctx, x, y, colored, size) {
  const hw = 180 * size, hh = 90 * size;
  const hc = colored ? '#2a5020' : '#333';
  ctx.fillStyle = hc;
  ctx.beginPath();
  ctx.moveTo(x - hw, y);
  ctx.bezierCurveTo(x - hw/2, y - hh, x + hw/2, y - hh, x + hw, y);
  ctx.fill();
}
function drawCastle(ctx, x, y, colored) {
  const cc = colored ? '#3a3060' : '#2a2a2a';
  const wc = colored ? '#a0c0ff' : '#444';
  const rc = colored ? '#aa2020' : '#333';
  // Main tower
  ctx.fillStyle = cc;
  ctx.fillRect(x-35, y-180, 70, 180);
  // Battlements
  [-30,-18,-6,6,18,28].forEach(bx => {
    ctx.fillRect(x+bx, y-200, 10, 22);
  });
  // Side towers
  [[-65,0.85],[65,0.85]].forEach(([dx,sc]) => {
    ctx.fillRect(x+dx-20*sc, y-140*sc, 40*sc, 140*sc);
    [-16,-6,4,14].forEach(bx => ctx.fillRect(x+dx+bx*sc, y-155*sc, 8*sc, 17*sc));
  });
  // Gate
  ctx.fillStyle = colored ? '#1a0a10' : '#111';
  ctx.beginPath();
  ctx.arc(x, y-20, 18, Math.PI, 0);
  ctx.rect(x-18, y-20, 36, 20);
  ctx.fill();
  // Windows
  ctx.fillStyle = wc;
  [[-18,-110],[18,-110],[0,-140],[-40,-90],[40,-90]].forEach(([dx,dy]) => {
    ctx.beginPath();
    ctx.arc(x+dx, y+dy, 7, Math.PI, 0);
    ctx.rect(x+dx-7, y+dy, 14, 10);
    ctx.fill();
  });
  // Flags
  if (colored) {
    [[-35+x,-178],[65+x,-126],[-65+x,-126]].forEach(([fx,fy]) => {
      ctx.fillStyle = rc;
      ctx.fillRect(fx, fy, 22, 14);
      ctx.strokeStyle='#888'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(fx,fy); ctx.lineTo(fx,fy+30); ctx.stroke();
    });
  }
}
function drawCrystal(ctx, x, y, colored, size, color, t) {
  const h = 55 * size, w = 18 * size;
  const pulse = colored ? (0.7 + Math.sin(t * 2.5) * 0.3) : 0;
  ctx.globalAlpha = colored ? 0.85 : 0.5;
  if (colored) {
    ctx.shadowColor = color; ctx.shadowBlur = 18 * pulse;
  }
  ctx.fillStyle = colored ? color : '#334';
  ctx.beginPath();
  ctx.moveTo(x, y - h);
  ctx.lineTo(x - w, y - h * 0.4);
  ctx.lineTo(x - w * 0.6, y);
  ctx.lineTo(x + w * 0.6, y);
  ctx.lineTo(x + w, y - h * 0.4);
  ctx.closePath();
  ctx.fill();
  ctx.shadowBlur = 0;
  // Highlight
  if (colored) {
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.moveTo(x, y - h);
    ctx.lineTo(x - w * 0.3, y - h * 0.5);
    ctx.lineTo(x, y - h * 0.7);
    ctx.closePath();
    ctx.fill();
  }
  ctx.globalAlpha = 1; ctx.shadowBlur = 0;
}
function drawStalactite(ctx, x, y, colored, size) {
  const h = 40 * size, w = 12 * size;
  ctx.fillStyle = colored ? '#2a1860' : '#222';
  ctx.globalAlpha = colored ? 0.9 : 0.5;
  ctx.beginPath();
  ctx.moveTo(x - w, y);
  ctx.lineTo(x + w, y);
  ctx.lineTo(x, y + h);
  ctx.closePath();
  ctx.fill();
  ctx.globalAlpha = 1;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  OBSTACLE / PLATFORM / POWERUP DRAW
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawBush(ctx, sx, sy, bw, bh, colored) {
  const baseY = sy + bh * 0.1;
  // Drop shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.beginPath(); ctx.ellipse(sx + bw/2, sy + bh, bw/2, bh*0.15, 0, 0, Math.PI*2); ctx.fill();

  const circles = [
    [sx + bw*0.5, baseY, bw*0.44, bh*0.75],
    [sx + bw*0.2, baseY + bh*0.08, bw*0.36, bh*0.65],
    [sx + bw*0.8, baseY + bh*0.08, bw*0.36, bh*0.65],
    [sx + bw*0.35, baseY - bh*0.05, bw*0.32, bh*0.55],
    [sx + bw*0.65, baseY - bh*0.05, bw*0.32, bh*0.55],
    [sx + bw*0.5, baseY - bh*0.1, bw*0.28, bh*0.5],
  ];
  const fc = colored ? '#228822' : '#444';
  const dc = colored ? '#185018' : '#333';

  circles.forEach(([cx,cy,rw,rh]) => {
    ctx.fillStyle = dc;
    ctx.beginPath(); ctx.ellipse(cx, cy+2, rw, rh, 0, 0, Math.PI*2); ctx.fill();
    // Red glow outline
    ctx.save();
    ctx.strokeStyle = '#dd1111';
    ctx.lineWidth = 2;
    ctx.shadowColor = '#dd1111'; ctx.shadowBlur = 8;
    ctx.beginPath(); ctx.ellipse(cx, cy, rw, rh, 0, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
    ctx.fillStyle = fc;
    ctx.beginPath(); ctx.ellipse(cx, cy, rw, rh, 0, 0, Math.PI*2); ctx.fill();
  });

  // Thorns
  const thornAngles = [0, 40, 80, 120, 160, 200, 240, 280, 320];
  ctx.fillStyle = colored ? '#bb4400' : '#555';
  thornAngles.forEach(deg => {
    const rad = deg * Math.PI / 180;
    const tx = sx + bw/2 + Math.cos(rad) * bw*0.48;
    const ty = baseY + Math.sin(rad) * bh*0.55;
    ctx.save();
    ctx.translate(tx, ty);
    ctx.rotate(rad + Math.PI/2);
    ctx.beginPath();
    ctx.moveTo(0, -7); ctx.lineTo(-3, 0); ctx.lineTo(3, 0);
    ctx.closePath(); ctx.fill();
    ctx.restore();
  });
}

function drawPlatform(ctx, sx, sy, pw, colored) {
  const ph = 14;
  // Wood
  const wc = colored ? '#8B5E1A' : '#444';
  ctx.fillStyle = wc;
  ctx.beginPath(); ctx.roundRect(sx, sy, pw, ph, 4); ctx.fill();
  // Moss top
  const mc = colored ? '#4a8a20' : '#333';
  ctx.fillStyle = mc;
  ctx.beginPath(); ctx.roundRect(sx, sy, pw, 5, [4,4,0,0]); ctx.fill();
  // Grass tufts
  if (colored) {
    ctx.fillStyle = '#5aaa28';
    for (let gx = sx+6; gx < sx+pw-4; gx += 14) {
      ctx.beginPath();
      ctx.moveTo(gx, sy); ctx.lineTo(gx-3, sy-6); ctx.lineTo(gx, sy-3); ctx.lineTo(gx+3, sy-6); ctx.lineTo(gx+3, sy);
      ctx.fill();
    }
  }
  // Wood grain
  ctx.strokeStyle = colored ? '#7a5010' : '#333';
  ctx.lineWidth = 1; ctx.globalAlpha = 0.4;
  for (let lx = sx+20; lx < sx+pw-8; lx += 22) {
    ctx.beginPath(); ctx.moveTo(lx, sy+4); ctx.lineTo(lx, sy+ph-2); ctx.stroke();
  }
  ctx.globalAlpha = 1;
}

function drawRainbowCircle(ctx, sx, sy, t) {
  // Spinning ring of 6 arc segments
  const r = 18;
  RAINBOW_COLORS.forEach((rc, i) => {
    const a0 = (i / 6) * Math.PI * 2 + t * 2;
    const a1 = a0 + Math.PI * 2 / 6 - 0.1;
    ctx.strokeStyle = rc; ctx.lineWidth = 5;
    ctx.shadowColor = rc; ctx.shadowBlur = 8;
    ctx.beginPath(); ctx.arc(sx, sy, r, a0, a1); ctx.stroke();
  });
  ctx.shadowBlur = 0;
  // White center glow
  const g = ctx.createRadialGradient(sx,sy,0,sx,sy,12);
  g.addColorStop(0,'rgba(255,255,255,0.95)'); g.addColorStop(1,'rgba(255,255,255,0)');
  ctx.fillStyle = g; ctx.beginPath(); ctx.arc(sx,sy,12,0,Math.PI*2); ctx.fill();
  // Gold star
  ctx.fillStyle = '#ffd700';
  drawStar(ctx, sx, sy, 5, 7, 3);
}
function drawShieldIcon(ctx, sx, sy, t) {
  ctx.save();
  ctx.translate(sx, sy);
  ctx.rotate(Math.sin(t * 1.5) * 0.08);
  // Hex
  ctx.strokeStyle = '#00cfff'; ctx.lineWidth = 4;
  ctx.shadowColor = '#00cfff'; ctx.shadowBlur = 14;
  ctx.fillStyle = 'rgba(0,180,255,0.25)';
  ctx.beginPath();
  for (let i = 0; i < 6; i++) {
    const a = (i / 6) * Math.PI * 2 - Math.PI/2;
    const hx = Math.cos(a)*16, hy = Math.sin(a)*16;
    i===0 ? ctx.moveTo(hx,hy) : ctx.lineTo(hx,hy);
  }
  ctx.closePath(); ctx.fill(); ctx.stroke();
  ctx.shadowBlur = 0;
  // Sparkle
  ctx.fillStyle = '#ffffff';
  ctx.font = '12px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText('âœ¦', 0, 0);
  ctx.restore();
}
function drawStar(ctx, cx, cy, n, r1, r2) {
  ctx.beginPath();
  for (let i = 0; i < n * 2; i++) {
    const r = i % 2 === 0 ? r1 : r2;
    const a = (i / (n*2)) * Math.PI * 2 - Math.PI/2;
    const px = cx + Math.cos(a)*r, py = cy + Math.sin(a)*r;
    i===0 ? ctx.moveTo(px,py) : ctx.lineTo(px,py);
  }
  ctx.closePath(); ctx.fill();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  RAINBOW TRAIL
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawTrail() {
  if (trailPoints.length < 2) return;
  const ponyScreenY = ponyY;
  RAINBOW_COLORS.forEach((rc, ri) => {
    const bandY = ponyScreenY - 5 + ri * 10;
    const wave = (wx, i) => Math.sin(time * 3 + i * 0.3 + ri * 0.8) * 2;
    ctx.beginPath();
    const pts = trailPoints.map((wp, i) => ({
      sx: wp - scrollX,
      sy: bandY + wave(wp, i)
    })).filter(p => p.sx < PONY_X);

    if (pts.length < 2) return;
    ctx.moveTo(pts[0].sx, pts[0].sy);
    pts.forEach(p => ctx.lineTo(p.sx, p.sy));
    ctx.lineTo(PONY_X, bandY);

    // Gradient: transparent at far left, opaque near pony
    const grad = ctx.createLinearGradient(pts[0].sx, 0, PONY_X, 0);
    grad.addColorStop(0, rc + '00');
    grad.addColorStop(0.06, rc + 'aa');
    grad.addColorStop(0.18, rc + 'ff');
    grad.addColorStop(1, rc + 'ff');

    ctx.strokeStyle = grad;
    ctx.lineWidth = 9;
    ctx.lineCap = 'round';
    ctx.stroke();
  });

  // Sparkle glow at pony attachment
  const pulse = 0.5 + Math.sin(time * 9) * 0.5;
  const glow = ctx.createRadialGradient(PONY_X, ponyScreenY + 25, 0, PONY_X, ponyScreenY + 25, 30 * pulse);
  glow.addColorStop(0, 'rgba(255,255,200,0.6)');
  glow.addColorStop(1, 'rgba(255,255,200,0)');
  ctx.fillStyle = glow;
  ctx.beginPath(); ctx.arc(PONY_X, ponyScreenY + 25, 30, 0, Math.PI*2); ctx.fill();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  PARTICLES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnParticles(x, y, n, type) {
  for (let i = 0; i < n; i++) {
    const angle = type === 'jump'
      ? (Math.PI/2 + (Math.random()-0.5)*Math.PI)
      : Math.random() * Math.PI * 2;
    const speed = type === 'jump' ? randBetween(2, 6) : randBetween(3, 8);
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed * (type === 'jump' ? 0.5 : 1),
      life: 1, maxLife: randBetween(0.6, 1),
      color: RAINBOW_COLORS[Math.floor(Math.random() * 6)],
      r: randBetween(2, 5)
    });
  }
}
function updateParticles() {
  particles = particles.filter(p => p.life > 0);
  particles.forEach(p => {
    p.x += p.vx; p.y += p.vy; p.vy += GRAVITY * 0.5;
    p.life -= 1 / (p.maxLife * 60);
  });
}
function drawParticles() {
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.r * p.life, 0, Math.PI*2); ctx.fill();
  });
  ctx.globalAlpha = 1;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  SPAWNING
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnObstacle() {
  const bh = randBetween(38, 74);
  const bw = randBetween(35, 65);
  obstacles.push({
    wx: scrollX + W + 60,
    y: GROUND_Y - bh,
    w: bw, h: bh
  });
}
function spawnPlatform() {
  const pw = randBetween(80, 150);
  const py = GROUND_Y - randBetween(110, 230);
  platforms.push({
    wx: scrollX + W + 60,
    y: py, w: pw, h: 14
  });
}
function spawnPowerup() {
  const isRainbow = Math.random() < 0.5;
  const py = GROUND_Y - randBetween(70, 180);
  powerups.push({
    wx: scrollX + W + 60,
    y: py,
    type: isRainbow ? 'rainbow' : 'shield',
    collected: false
  });
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  COLLISION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function ponyRect() {
  return { x: PONY_X - 28, y: ponyY - 14, w: 56, h: 46 };
}
function rectsOverlap(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x &&
         a.y < b.y + b.h && a.y + a.h > b.y;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  SHIELD DRAW
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawShieldEffect() {
  if (shieldTimer <= 0) return;
  const pulse = 0.6 + Math.sin(time * 8) * 0.4;
  ctx.save();
  ctx.strokeStyle = `rgba(0,200,255,${pulse})`;
  ctx.lineWidth = 3;
  ctx.shadowColor = '#00cfff'; ctx.shadowBlur = 16;
  ctx.beginPath();
  ctx.arc(PONY_X, ponyY + 16, 40, 0, Math.PI*2);
  ctx.stroke();
  ctx.restore();
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  HUD
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawHUD() {
  // Score
  ctx.font = '28px "Fredoka One", cursive';
  ctx.textAlign = 'right'; ctx.textBaseline = 'top';
  ctx.fillStyle = '#fff';
  ctx.shadowColor = '#000'; ctx.shadowBlur = 6;
  ctx.fillText(Math.floor(distance), W - 20, 16);
  ctx.shadowBlur = 0;
  ctx.font = '13px Nunito';
  ctx.fillText('DISTANCE', W - 20, 48);

  // Zone label
  ctx.font = '16px "Fredoka One", cursive';
  ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
  ctx.fillStyle = 'rgba(255,255,255,0.75)';
  ctx.fillText(zoneLabel, W/2, H - 12);

  // Power-up indicators
  ctx.textAlign = 'left'; ctx.textBaseline = 'top';
  let hudY = 16;
  if (rainbowMode > 0) {
    ctx.font = '18px "Fredoka One", cursive';
    ctx.fillStyle = '#ffd700';
    ctx.shadowColor = '#ff8800'; ctx.shadowBlur = 10;
    ctx.fillText('âš¡ RAINBOW MODE', 16, hudY);
    ctx.shadowBlur = 0;
    hudY += 32;
  }
  if (shieldTimer > 0) {
    ctx.font = '18px "Fredoka One", cursive';
    ctx.fillStyle = '#00cfff';
    ctx.shadowColor = '#00cfff'; ctx.shadowBlur = 10;
    ctx.fillText('ğŸ›¡ SHIELD', 16, hudY);
    ctx.shadowBlur = 0;
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  GAME OVER SCREEN
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let finalScore = 0;
function drawGameOver() {
  ctx.fillStyle = `rgba(0,0,0,${overlayAlpha})`;
  ctx.fillRect(0, 0, W, H);
  if (overlayAlpha < 0.85) return;
  ctx.textAlign = 'center';
  ctx.font = '72px "Fredoka One", cursive';
  ctx.fillStyle = '#ff4444';
  ctx.shadowColor = '#000'; ctx.shadowBlur = 20;
  ctx.fillText('Game Over', W/2, H/2 - 80);
  ctx.font = '34px "Fredoka One", cursive';
  ctx.fillStyle = '#fff';
  ctx.fillText(`Distance: ${Math.floor(finalScore)}`, W/2, H/2 - 10);
  // Try Again button â€” drawn on canvas
  ctx.fillStyle = '#ffd700';
  ctx.shadowColor = '#ff8800'; ctx.shadowBlur = 16;
  ctx.beginPath(); ctx.roundRect(W/2 - 100, H/2 + 50, 200, 54, 28); ctx.fill();
  ctx.shadowBlur = 0;
  ctx.fillStyle = '#1a0a2e';
  ctx.font = '24px "Fredoka One", cursive';
  ctx.fillText('Try Again', W/2, H/2 + 79);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  INPUT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function handleJump() {
  if (gameState !== 'playing' || isDead) return;
  const unlimited = rainbowMode > 0;
  if (unlimited || jumpsLeft > 0) {
    const force = unlimited ? JUMP_FORCE * 0.72 : JUMP_FORCE;
    ponyVY = force;
    if (!unlimited) jumpsLeft--;
    playJump();
    spawnParticles(PONY_X, ponyY + 40, 8, 'jump');
  }
}

window.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'ArrowUp') {
    e.preventDefault();
    handleJump();
  }
});
canvas.addEventListener('click', e => {
  if (gameState === 'dead' && overlayAlpha >= 0.85) {
    const cx = e.offsetX, cy = e.offsetY;
    if (cx > W/2-100 && cx < W/2+100 && cy > H/2+50 && cy < H/2+104) {
      startGame();
    }
  } else {
    handleJump();
  }
});
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  handleJump();
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  GAME START / RESET
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startGame() {
  scrollX = 0; distance = 0; gameSpeed = 6; time = 0; shake = 0;
  ponyY = GROUND_Y - 40; ponyVY = 0; jumpsLeft = MAX_JUMPS;
  isDead = false; deathTimer = 0; overlayAlpha = 0; finalScore = 0;
  rainbowMode = 0; shieldTimer = 0;
  obstacles = []; platforms = []; powerups = []; particles = []; trailPoints = [];
  obstacleTimer = 80; platformTimer = 150; powerupTimer = 250;
  zoneLabel = ZONES[0].name;
  buildBgObjects();
  gameState = 'playing';
  document.getElementById('titleScreen').style.display = 'none';
  canvas.style.display = 'block';
  requestAnimationFrame(gameLoop);
}

document.getElementById('startBtn').addEventListener('click', startGame);

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  MAIN GAME LOOP
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gameLoop() {
  time += 1/60;
  update();
  render();
  requestAnimationFrame(gameLoop);
}

function update() {
  if (gameState !== 'playing') return;

  gameSpeed = 6 + distance / 2200;

  if (!isDead) {
    // Scroll
    const speed = rainbowMode > 0 ? gameSpeed * 1.65 : gameSpeed;
    scrollX += speed;
    distance += speed;

    // Zone label
    const { zi } = getZoneProgress(distance);
    zoneLabel = ZONES[zi].name;

    // Trail
    trailPoints.push(scrollX + PONY_X);
    if (trailPoints.length > 120) trailPoints.shift();

    // Pony physics
    ponyVY += GRAVITY;
    ponyY += ponyVY;
    if (ponyY >= GROUND_Y - 40) {
      ponyY = GROUND_Y - 40;
      ponyVY = 0;
      jumpsLeft = rainbowMode > 0 ? jumpsLeft : MAX_JUMPS;
    }

    // Platform landing
    const pr = ponyRect();
    platforms.forEach(p => {
      const sr = { x: p.wx - scrollX, y: p.y, w: p.w, h: p.h };
      if (ponyVY >= 0 && pr.y + pr.h > sr.y && pr.y + pr.h < sr.y + sr.h + 12 &&
          pr.x + pr.w > sr.x + 8 && pr.x < sr.x + sr.w - 8) {
        ponyY = p.y - pr.h + pr.h/2 + 6;
        ponyVY = 0;
        jumpsLeft = MAX_JUMPS;
      }
    });

    // Power-up timers
    if (rainbowMode > 0) rainbowMode--;
    if (shieldTimer > 0) shieldTimer--;

    // Spawn obstacles
    obstacleTimer--;
    if (obstacleTimer <= 0) {
      spawnObstacle();
      obstacleTimer = randInt(55, 130);
    }
    platformTimer--;
    if (platformTimer <= 0) {
      spawnPlatform();
      platformTimer = randInt(95, 210);
    }
    powerupTimer--;
    if (powerupTimer <= 0) {
      spawnPowerup();
      powerupTimer = randInt(180, 380);
    }

    // Cleanup off-screen
    const cullX = scrollX - 200;
    obstacles = obstacles.filter(o => o.wx > cullX);
    platforms = platforms.filter(p => p.wx > cullX);
    powerups = powerups.filter(p => p.wx > cullX && !p.collected);

    // Collisions â€” obstacles
    obstacles.forEach(o => {
      const sx = o.wx - scrollX;
      const oRect = { x: sx + 6, y: o.y + 6, w: o.w - 12, h: o.h - 6 };
      if (rectsOverlap(pr, oRect)) {
        if (shieldTimer > 0) return;
        die();
      }
    });

    // Collisions â€” powerups
    powerups.forEach(p => {
      if (p.collected) return;
      const sx = p.wx - scrollX;
      const pRect = { x: sx - 20, y: p.y - 20, w: 40, h: 40 };
      if (rectsOverlap(pr, pRect)) {
        p.collected = true;
        if (p.type === 'rainbow') {
          rainbowMode = 300;
          playRainbowPickup();
          spawnParticles(PONY_X, ponyY, 24, 'death');
        } else {
          shieldTimer = 420;
          playShieldPickup();
          spawnParticles(PONY_X, ponyY, 12, 'jump');
        }
      }
    });

  } else {
    // Dying
    deathTimer++;
    overlayAlpha = clamp((deathTimer - 65) / 65, 0, 0.88);
    if (shake > 0) shake -= 1.6;
  }

  updateParticles();
}

function die() {
  if (isDead) return;
  isDead = true;
  gameState = 'dead';
  finalScore = distance;
  shake = 28;
  playDeath();
  spawnParticles(PONY_X, ponyY + 20, 22, 'death');
}

function render() {
  ctx.save();
  // Screen shake
  if (shake > 0) {
    ctx.translate(
      (Math.random()-0.5)*shake*1.5,
      (Math.random()-0.5)*shake*1.5
    );
  }

  const splitX = PONY_X;

  // Background
  drawBackground(splitX);

  // Trail (behind pony)
  drawTrail();

  // Platforms
  platforms.forEach(p => {
    const sx = p.wx - scrollX;
    const colored = sx < splitX;
    drawPlatform(ctx, sx, p.y, p.w, colored);
  });

  // Obstacles
  obstacles.forEach(o => {
    const sx = o.wx - scrollX;
    const colored = sx < splitX;
    drawBush(ctx, sx, o.y, o.w, o.h, colored);
  });

  // Power-ups
  powerups.forEach(p => {
    if (p.collected) return;
    const sx = p.wx - scrollX;
    if (p.type === 'rainbow') drawRainbowCircle(ctx, sx, p.y, time);
    else drawShieldIcon(ctx, sx, p.y, time);
  });

  // Shield effect
  drawShieldEffect();

  // Pony
  const pony = PONIES[selectedPony];
  drawPonyPortrait(ctx, pony, PONY_X, ponyY + 40, 1, time * 60, isDead, rainbowMode > 0);

  // Particles
  drawParticles();

  // HUD
  drawHUD();

  // Game over overlay
  if (isDead) drawGameOver();

  ctx.restore();
}
</script>
</body>
</html>
