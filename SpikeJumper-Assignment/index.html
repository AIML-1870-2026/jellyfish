<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Rainbow Runners</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@400;700;900&display=swap');
  * { margin:0; padding:0; box-sizing:border-box; }
  body {
    background: #0d0010;
    display: flex; align-items: center; justify-content: center;
    min-height: 100vh; font-family: 'Nunito', sans-serif; overflow: hidden;
  }
  #app { position: relative; width: 1100px; height: 620px; }
  canvas { display: block; border-radius: 14px; box-shadow: 0 0 80px rgba(120,0,180,0.5); }
  #ui { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; }
  #score-display {
    position:absolute; top:16px; right:20px;
    font-family:'Fredoka One',cursive; font-size:28px; color:white;
    text-shadow: 2px 2px 0 rgba(0,0,0,0.6);
  }
  #powerup-bar { position:absolute; top:16px; left:20px; display:flex; gap:10px; align-items:center; }
  .powerup-indicator {
    padding:4px 14px; border-radius:20px; font-size:13px; font-weight:900; color:white;
    opacity:0; transition:opacity 0.3s;
  }
  .powerup-indicator.active { opacity:1; }
  #rainbow-indicator {
    background:linear-gradient(90deg,#f00,#ff7700,#ff0,#0f0,#00f,#8b00ff);
    animation:hue-shift 1s linear infinite; background-size:200%;
  }
  @keyframes hue-shift { 0%{filter:hue-rotate(0deg)} 100%{filter:hue-rotate(360deg)} }
  #shield-indicator { background:rgba(80,180,255,0.85); border:2px solid #fff; }

  .screen {
    position:absolute; top:0; left:0; width:100%; height:100%;
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    pointer-events:all; border-radius:14px;
  }
  #select-screen { background:linear-gradient(160deg,#0a0020 0%,#1a0535 50%,#0a1530 100%); }
  #select-screen h1 {
    font-family:'Fredoka One',cursive; font-size:56px;
    background:linear-gradient(90deg,#f00,#ff7700,#ff0,#0f0,#00f,#8b00ff,#f00);
    -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text;
    margin-bottom:10px; animation:rbg 3s linear infinite; background-size:300%;
    filter:drop-shadow(0 0 20px rgba(200,100,255,0.5));
  }
  @keyframes rbg { 0%{background-position:0%} 100%{background-position:300%} }
  #select-screen .subtitle { color:#998aaa; margin-bottom:14px; font-size:15px; letter-spacing:1px; text-align:center; }
  #title-layout { display:flex; gap:24px; align-items:flex-start; width:100%; max-width:1060px; padding:0 16px; }
  #story-panel { flex:1; display:flex; flex-direction:column; gap:10px; max-width:520px; }
  #story-box, #zones-box, #controls-box {
    background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1);
    border-radius:12px; padding:12px 16px;
  }
  #story-box h3, #zones-box h3, #controls-box h3 {
    font-family:'Fredoka One',cursive; font-size:15px; color:#ddbbff;
    margin-bottom:7px; letter-spacing:1px;
  }
  #story-box p, #controls-box p { color:#bbb; font-size:12px; line-height:1.55; margin-bottom:4px; }
  .zone-entry { display:flex; gap:10px; align-items:flex-start; margin-bottom:7px; }
  .zone-icon { font-size:20px; flex-shrink:0; margin-top:1px; }
  .zone-entry div { color:#bbb; font-size:11.5px; line-height:1.5; }
  .zone-entry strong { color:#eeddff; font-size:12px; }
  kbd { background:rgba(255,255,255,0.12); border:1px solid rgba(255,255,255,0.25); border-radius:4px; padding:1px 5px; font-size:11px; color:#fff; }
  .rb { color:#ffcc44; font-weight:700; }
  .sh { color:#88ddff; font-weight:700; }
  #pony-chooser { display:flex; flex-direction:column; align-items:center; flex-shrink:0; }
  .pony-grid { display:grid; grid-template-columns:repeat(3,1fr); gap:14px; margin-bottom:28px; }
  .pony-card {
    width:120px; background:rgba(255,255,255,0.04); border:2px solid rgba(255,255,255,0.1);
    border-radius:16px; padding:14px 10px; cursor:pointer; transition:all 0.2s;
    text-align:center; display:flex; flex-direction:column; align-items:center; gap:8px;
  }
  .pony-card:hover { border-color:rgba(255,255,255,0.4); transform:translateY(-4px); background:rgba(255,255,255,0.08); }
  .pony-card.selected { border-color:gold; background:rgba(255,215,0,0.12); box-shadow:0 0 24px rgba(255,215,0,0.25); }
  .pony-card canvas { border-radius:8px; box-shadow:none; }
  .pony-card span { font-size:12px; font-weight:700; color:#ccc; }
  #start-btn {
    font-family:'Fredoka One',cursive; font-size:26px; padding:14px 52px;
    border:none; border-radius:40px;
    background:linear-gradient(90deg,#f00,#ff7700,#ff0,#0f0,#00f,#8b00ff,#f00);
    background-size:300%; color:white; cursor:pointer;
    animation:rbg 2s linear infinite; transition:transform 0.15s,box-shadow 0.15s;
    text-shadow:1px 1px 2px rgba(0,0,0,0.4);
  }
  #start-btn:hover { transform:scale(1.07); box-shadow:0 8px 32px rgba(180,80,255,0.5); }
  #gameover-screen { background:rgba(0,0,0,0.88); display:none; }
  #gameover-screen h2 { font-family:'Fredoka One',cursive; font-size:68px; color:#fff; margin-bottom:10px; }
  #gameover-screen p { color:#aaa; font-size:20px; margin-bottom:28px; }
  #restart-btn {
    font-family:'Fredoka One',cursive; font-size:22px; padding:12px 42px;
    border:2px solid white; border-radius:40px; background:transparent; color:white;
    cursor:pointer; transition:all 0.2s;
  }
  #restart-btn:hover { background:white; color:#111; }
  #zone-label {
    position:absolute; bottom:16px; left:50%; transform:translateX(-50%);
    font-family:'Fredoka One',cursive; font-size:17px; color:rgba(255,255,255,0.65);
    text-shadow:1px 1px 6px rgba(0,0,0,0.9); letter-spacing:3px; text-transform:uppercase;
  }
</style>
</head>
<body>
<div id="app">
  <canvas id="gameCanvas" width="1100" height="620"></canvas>
  <div id="ui">
    <div id="score-display">Score: <span id="score">0</span></div>
    <div id="powerup-bar">
      <div class="powerup-indicator" id="rainbow-indicator">‚ö° RAINBOW MODE</div>
      <div class="powerup-indicator" id="shield-indicator">üõ° SHIELD</div>
    </div>
    <div id="zone-label"></div>
  </div>
  <div class="screen" id="select-screen">
    <h1>Rainbow Runners</h1>

    <div id="title-layout">
      <div id="story-panel">
        <div id="story-box">
          <h3>‚ú® A World Without Color</h3>
          <p>Once, the land was vibrant and full of life ‚Äî but a mysterious shadow drained every last drop of color from the world, leaving it cold and grey.</p>
          <p>Only a magical pony and her rainbow trail can bring it back. Run through each zone, and watch the world bloom with color in your wake!</p>
        </div>
        <div id="zones-box">
          <h3>üó∫ The Journey</h3>
          <div class="zone-entry"><span class="zone-icon">üçé</span><div><strong>Apple Orchard</strong><br>A once-lush grove of apple trees, now still and grey. Leap the thorny overgrowth!</div></div>
          <div class="zone-entry"><span class="zone-icon">üåë</span><div><strong>Spooky Forest</strong><br>Dead trees and swooping bats lurk in the dark. Stay sharp!</div></div>
          <div class="zone-entry"><span class="zone-icon">üè∞</span><div><strong>Castle Fields</strong><br>Rolling hills lead to a grand castle. Jump high to reach the platforms!</div></div>
          <div class="zone-entry"><span class="zone-icon">üíé</span><div><strong>Crystal Caves</strong><br>Glittering crystals line the cavern walls ‚Äî the deepest, hardest stage.</div></div>
        </div>
        <div id="controls-box">
          <h3>üéÆ How to Play</h3>
          <p><kbd>Space</kbd> or <strong>click</strong> to jump ‚Äî up to 3 times in the air!</p>
          <p>Collect <span class="rb">‚ö° Rainbow Circles</span> for speed &amp; infinite flight.</p>
          <p>Collect <span class="sh">üõ° Shields</span> for 7 seconds of invincibility.</p>
        </div>
      </div>

      <div id="pony-chooser">
        <p class="subtitle">Choose your pony</p>
        <div class="pony-grid" id="pony-grid"></div>
        <button id="start-btn">Let's Run! üåà</button>
      </div>
    </div>
  </div>
  <div class="screen" id="gameover-screen">
    <h2>Game Over</h2>
    <p id="final-score">Score: 0</p>
    <button id="restart-btn">Try Again</button>
  </div>
</div>

<script>

// ===================== POLYFILLS =====================
// roundRect polyfill for browsers that don't support it (Safari < 15.4, older Chrome, GitHub Pages)
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
    if (typeof r === 'object') {
      // Handle array form [tl, tr, br, bl]
      var tl = r[0]||0, tr = r[1]||0, br = r[2]||0, bl = r[3]||0;
    } else {
      var tl = r||0, tr = r||0, br = r||0, bl = r||0;
    }
    tl = Math.min(tl, w/2, h/2);
    tr = Math.min(tr, w/2, h/2);
    br = Math.min(br, w/2, h/2);
    bl = Math.min(bl, w/2, h/2);
    this.moveTo(x + tl, y);
    this.lineTo(x + w - tr, y);
    this.arcTo(x + w, y, x + w, y + tr, tr);
    this.lineTo(x + w, y + h - br);
    this.arcTo(x + w, y + h, x + w - br, y + h, br);
    this.lineTo(x + bl, y + h);
    this.arcTo(x, y + h, x, y + h - bl, bl);
    this.lineTo(x, y + tl);
    this.arcTo(x, y, x + tl, y, tl);
    this.closePath();
    return this;
  };
}

// ===================== AUDIO =====================
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function getAudio() { if (!audioCtx) audioCtx = new AudioCtx(); return audioCtx; }

function playJump() {
  try {
    const ac = getAudio(), o = ac.createOscillator(), g = ac.createGain();
    o.connect(g); g.connect(ac.destination);
    o.frequency.setValueAtTime(280, ac.currentTime);
    o.frequency.exponentialRampToValueAtTime(560, ac.currentTime + 0.12);
    g.gain.setValueAtTime(0.25, ac.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, ac.currentTime + 0.22);
    o.start(); o.stop(ac.currentTime + 0.22);
  } catch(e){}
}

function playPowerup() {
  try {
    const ac = getAudio();
    [300,500,700,900,1100,1400].forEach((f,i) => {
      const o = ac.createOscillator(), g = ac.createGain();
      o.connect(g); g.connect(ac.destination); o.frequency.value = f; o.type = 'sine';
      const t = ac.currentTime + i*0.07;
      g.gain.setValueAtTime(0.18, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.18);
      o.start(t); o.stop(t+0.18);
    });
  } catch(e){}
}

function playDie() {
  try {
    const ac = getAudio(), o = ac.createOscillator(), g = ac.createGain();
    o.connect(g); g.connect(ac.destination); o.type = 'sawtooth';
    o.frequency.setValueAtTime(350, ac.currentTime);
    o.frequency.exponentialRampToValueAtTime(70, ac.currentTime + 0.7);
    g.gain.setValueAtTime(0.4, ac.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, ac.currentTime + 0.7);
    o.start(); o.stop(ac.currentTime + 0.7);
  } catch(e){}
}

function playShield() {
  try {
    const ac = getAudio();
    [500,750,600,900].forEach((f,i) => {
      const o = ac.createOscillator(), g = ac.createGain();
      o.connect(g); g.connect(ac.destination); o.frequency.value = f; o.type = 'sine';
      const t = ac.currentTime + i*0.08;
      g.gain.setValueAtTime(0.22, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.15);
      o.start(t); o.stop(t+0.15);
    });
  } catch(e){}
}

// ===================== PONIES =====================
const PONIES = [
  { name: 'Twilight',   body: '#7b3f9e', mane: '#4a0080', mane2: '#9933ff', tail: '#6a2dcc' },
  { name: 'Pinkie',     body: '#f06fa0', mane: '#e03880', mane2: '#ff66aa', tail: '#ff99cc' },
  { name: 'Fluttershy', body: '#f8f0b0', mane: '#ffb3b3', mane2: '#ffd0d0', tail: '#ffe0a0' },
  { name: 'Applejack',  body: '#e8a832', mane: '#ff6b35', mane2: '#ffaa55', tail: '#f0c060' },
  { name: 'Rainbow',    body: '#60b0ff', mane: '#ff3344', mane2: '#ff7722', tail: '#44dd44' },
  { name: 'Rarity',     body: '#f0ecff', mane: '#9933dd', mane2: '#cc77ff', tail: '#bb66ee' },
];

// ===================== CONSTANTS =====================
const W = 1100, H = 620, GROUND_Y = 510, PONY_X = 160;
const GRAVITY = 0.55, JUMP_FORCE = -13.5, MAX_JUMPS = 3;
const RAINBOW_COLORS = ['#ff0000','#ff7700','#ffee00','#00dd00','#0088ff','#aa00ff'];

// ===================== CANVAS =====================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// ===================== ZONES =====================
const ZONES = [
  {
    name: 'APPLE ORCHARD',
    skyTop: '#1a3a08', skyBot: '#2a5010',   // warm green dawn
    groundMain: '#3a5a18', groundLine: '#2a4010',
    dist: 0,
  },
  {
    name: 'SPOOKY FOREST',
    skyTop: '#0a0820', skyBot: '#180830',   // deep purple night
    groundMain: '#1a1018', groundLine: '#100810',
    dist: 900,
  },
  {
    name: 'CASTLE FIELDS',
    skyTop: '#082040', skyBot: '#103060',   // rich blue twilight
    groundMain: '#204030', groundLine: '#183828',
    dist: 2200,
  },
  {
    name: 'CRYSTAL CAVES',
    skyTop: '#080520', skyBot: '#100a30',   // deep indigo cave
    groundMain: '#141028', groundLine: '#0c0820',
    dist: 3800,
  },
];

// ===================== GAME STATE =====================
let gameState = 'select';
let selectedPony = 0;
let score = 0, distance = 0, gameSpeed = 6;
let ponyY = GROUND_Y, ponyVY = 0, onGround = true, jumpCount = 0;
let dying = false, deathTimer = 0;
let rainbowMode = false, rainbowTimer = 0;
let shieldMode = false, shieldTimer = 0;
let shake = 0, shakeX = 0, shakeY = 0;
let time = 0, scrollX = 0;
let currentZone = 0;

let trailPoints = []; // horizontal dress trail
let particles = [];
let obstacles = [], platforms = [], powerups = [];
let bgObjects = [];
let colorRevealX = 0; // world-x behind which color has been revealed

let spawnTimer = 60, platformTimer = 120, powerupTimer = 220;

// ===================== BG OBJECTS =====================
function initBgObjects() {
  bgObjects = [];
  // scrollX grows at roughly 2x distance (speed=6, distance+=speed*0.5 per frame at dt=1)
  // Zone scrollX boundaries: zone0=0, zone1=1800, zone2=4400, zone3=7600
  // bg bx = wx - scrollX * depth. We want objects to appear when zone is active.
  // wx_start for zone N ‚âà zone_scrollX_start * depth_avg
  // Use fixed depth=0.35 for placement math, actual depth varies per object.

  // Zone 0: APPLE ORCHARD ‚Äî scrollX 0 to 1800
  // wx range: 0 to 1800*0.35 + W = 0 to 1730
  for (let i = 0; i < 24; i++) {
    const depth = 0.25 + Math.random() * 0.4;
    bgObjects.push({ type:'appletree', wx: 100 + i * 160 + Math.random()*60, depth, size: 60 + Math.random()*45 });
  }

  // Zone 1: SPOOKY FOREST ‚Äî scrollX 1800 to 4400
  // wx start ‚âà 1800*0.35 = 630, end ‚âà 4400*0.45 + W = 3080
  for (let i = 0; i < 20; i++) {
    const depth = 0.25 + Math.random() * 0.45;
    bgObjects.push({ type:'deadtree', wx: 700 + i * 200 + Math.random()*80, depth, size: 80 + Math.random()*60 });
  }
  for (let i = 0; i < 9; i++) {
    bgObjects.push({ type:'bat', wx: 750 + i * 270 + Math.random()*120, depth: 0.55 + Math.random()*0.3, size: 14 + Math.random()*10 });
  }

  // Zone 2: CASTLE FIELDS ‚Äî scrollX 4400 to 7600
  // wx start ‚âà 4400*0.35 = 1540, end ‚âà 7600*0.45 + W = 4520
  // Castle at very low depth so it's huge and far back
  bgObjects.push({ type:'castle', wx: 1700, depth: 0.08, size: 1 });
  for (let i = 0; i < 10; i++) {
    const depth = 0.15 + Math.random() * 0.22;
    bgObjects.push({ type:'hill', wx: 1540 + i * 300 + Math.random()*100, depth, size: 120 + Math.random()*80 });
  }

  // Zone 3: CRYSTAL CAVES ‚Äî scrollX 7600+
  // wx start ‚âà 7600*0.35 = 2660  ‚Äî dense layered crystals at multiple depths
  for (let i = 0; i < 50; i++) {
    const depth = 0.1 + Math.random() * 0.55;
    bgObjects.push({ type:'crystal', wx: 2600 + i * 90 + Math.random()*60, depth, size: 35 + Math.random()*100 });
  }
  // Extra foreground crystals (bigger, closer)
  for (let i = 0; i < 18; i++) {
    bgObjects.push({ type:'crystal', wx: 2650 + i * 240 + Math.random()*80, depth: 0.6 + Math.random()*0.3, size: 70 + Math.random()*60 });
  }
  // Tiny background crystals for depth
  for (let i = 0; i < 30; i++) {
    bgObjects.push({ type:'crystal', wx: 2620 + i * 130 + Math.random()*50, depth: 0.05 + Math.random()*0.08, size: 20 + Math.random()*40 });
  }
}

// ===================== HELPER: colorize =====================
function isColorized(worldX) {
  // The pony at PONY_X has world coordinate = scrollX + PONY_X
  // We reveal color behind the pony's current world position
  return (scrollX + PONY_X) > worldX;
}

function zoneColor(hex, worldX, satBoost) {
  // Returns color or gray depending on whether the world position has been colorized
  if (isColorized(worldX)) return hex;
  // Convert to grayscale
  const r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
  const avg = Math.round(r*0.299 + g*0.587 + b*0.114);
  const v = Math.min(255, avg + 10);
  return `rgb(${v},${v},${v})`;
}

function lerp(a,b,t){ return a+(b-a)*t; }
function lerpHex(c1,c2,t){
  const p=hex=>[parseInt(hex.slice(1,3),16),parseInt(hex.slice(3,5),16),parseInt(hex.slice(5,7),16)];
  const a=p(c1),b=p(c2);
  return `rgb(${Math.round(lerp(a[0],b[0],t))},${Math.round(lerp(a[1],b[1],t))},${Math.round(lerp(a[2],b[2],t))})`;
}

// ===================== DRAW BG =====================
function drawBackground() {
  const zone = currentZone;
  const z = ZONES[zone], zn = ZONES[Math.min(zone+1, ZONES.length-1)];
  const nextDist = zone < ZONES.length-1 ? ZONES[zone+1].dist : Infinity;
  const subT = Math.min((distance - z.dist) / Math.max(1, nextDist - z.dist), 1);

  // Sky ‚Äî always a bit colored (atmosphere), grayscale for areas ahead
  // We draw sky in two halves: left=passed (color), right=ahead (gray)
  const ponyScreenX = PONY_X;

  // Left (revealed) sky
  const skyTopCol = zone < ZONES.length-1 ? lerpHex(z.skyTop, zn.skyTop, subT) : z.skyTop;
  const skyBotCol = zone < ZONES.length-1 ? lerpHex(z.skyBot, zn.skyBot, subT) : z.skyBot;

  // Draw full sky first in grayscale
  const grayTop = '#111', grayBot = '#222';
  const g1 = ctx.createLinearGradient(0,0,0,GROUND_Y);
  g1.addColorStop(0, grayTop); g1.addColorStop(1, grayBot);
  ctx.fillStyle = g1; ctx.fillRect(0, 0, W, GROUND_Y);

  // Then overlay colorized sky on left half (pony has passed)
  if (ponyScreenX > 0) {
    const g2 = ctx.createLinearGradient(0,0,0,GROUND_Y);
    g2.addColorStop(0, skyTopCol); g2.addColorStop(1, skyBotCol);
    ctx.fillStyle = g2;
    ctx.fillRect(0, 0, ponyScreenX, GROUND_Y);
  }

  // Background elements ‚Äî use looped scroll so zones repeat each cycle
  const CYCLE_SCROLL = 5300 * 2; // scrollX equivalent of one full distance cycle
  const loopedScrollX = scrollX % CYCLE_SCROLL;
  bgObjects.forEach(obj => {
    // Try the object in the current cycle and the previous cycle for seamless wrap
    for (const sc of [loopedScrollX, loopedScrollX - CYCLE_SCROLL]) {
      const bx = obj.wx - sc * obj.depth;
      if (bx < -200 || bx > W + 200) continue;
      // Color reveal based on screen position: colored if the object is LEFT of the pony
      const colored = bx < PONY_X;

      if (obj.type === 'appletree') drawAppleTree(bx, GROUND_Y, obj.size, colored);
      if (obj.type === 'deadtree') drawDeadTree(bx, GROUND_Y, obj.size, colored, time + obj.wx);
      if (obj.type === 'castle') drawCastle(bx, GROUND_Y, colored);
      if (obj.type === 'hill') drawHill(bx, GROUND_Y, obj.size, colored);
      if (obj.type === 'crystal') drawBgCrystal(bx, GROUND_Y, obj.size, colored, time + obj.wx);
      if (obj.type === 'bat') drawBat(bx, 80 + Math.sin(time*2 + obj.wx)*30, obj.size, colored, time + obj.wx*0.01);
      break; // only draw once per object
    }
  });

  // Moon/sun
  drawAtmosphere(zone, colored_sky_x=ponyScreenX, subT);
}

function drawAtmosphere(zone, revealX, subT) {
  // Zone 0: daytime sun (right side gray, left colorized)
  if (zone === 0) {
    const sunX = 800, sunY = 80;
    const col = isColorized(scrollX + sunX) ? '#ffe060' : '#aaa';
    ctx.save();
    ctx.globalAlpha = 0.5;
    ctx.fillStyle = col;
    ctx.beginPath(); ctx.arc(sunX, sunY, 40, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }
  // Zone 1: moon
  if (zone === 1) {
    const mx = 750, my = 70;
    const col = isColorized(scrollX + mx) ? '#eeeeff' : '#888';
    ctx.save(); ctx.globalAlpha = 0.7;
    ctx.fillStyle = col; ctx.beginPath(); ctx.arc(mx, my, 30, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }
  // Zone 3: glowing ceiling stalactites hint
  if (zone === 3) {
    for (let i = 0; i < 8; i++) {
      const sx = ((i * 130 - scrollX * 0.05) % W + W) % W;
      const col = isColorized(scrollX + sx) ? `hsl(${i*40+200},80%,60%)` : '#444';
      ctx.save(); ctx.globalAlpha = 0.3;
      ctx.fillStyle = col; ctx.beginPath(); ctx.moveTo(sx,0); ctx.lineTo(sx-12, 40); ctx.lineTo(sx+12, 40); ctx.fill();
      ctx.restore();
    }
  }
}

function drawAppleTree(x, groundY, size, colored) {
  const trunkH = size * 0.55, trunkW = size * 0.09;
  const foliageR = size * 0.42;
  ctx.save();
  // Trunk
  ctx.fillStyle = colored ? '#5c3010' : '#444';
  ctx.beginPath();
  ctx.roundRect(x - trunkW/2, groundY - trunkH, trunkW, trunkH, 3);
  ctx.fill();
  // Foliage (3 circles)
  const fc = colored ? '#2d8a18' : '#333';
  const fc2 = colored ? '#3aac22' : '#3a3a3a';
  [[0,-trunkH],[foliageR*0.5,-trunkH+foliageR*0.2],[-foliageR*0.5,-trunkH+foliageR*0.2]].forEach(([dx,dy],i) => {
    ctx.fillStyle = i===0 ? fc2 : fc;
    ctx.beginPath(); ctx.arc(x+dx, groundY+dy, foliageR * (i===0 ? 1 : 0.75), 0, Math.PI*2); ctx.fill();
  });
  // Apples
  if (colored) {
    for (let a = 0; a < 5; a++) {
      const ax = x + Math.cos(a * 1.3) * foliageR * 0.55;
      const ay = groundY - trunkH + Math.sin(a * 1.3) * foliageR * 0.35 - foliageR*0.1;
      ctx.fillStyle = '#dd2222'; ctx.beginPath(); ctx.arc(ax, ay, 5, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#228833'; ctx.fillRect(ax-1, ay-7, 2, 5);
    }
  }
  ctx.restore();
}

function drawDeadTree(x, groundY, size, colored, seed) {
  ctx.save();
  const col = colored ? '#2a1a08' : '#2a2a2a';
  ctx.strokeStyle = col; ctx.lineWidth = size * 0.065; ctx.lineCap = 'round';
  const h = size * 0.85;
  ctx.beginPath(); ctx.moveTo(x, groundY); ctx.lineTo(x, groundY - h); ctx.stroke();
  // Branches
  ctx.lineWidth = size * 0.035;
  for (let b = 0; b < 5; b++) {
    const by = groundY - h * (0.4 + b * 0.12);
    const bLen = size * (0.3 - b * 0.03);
    const side = b % 2 === 0 ? 1 : -1;
    ctx.beginPath(); ctx.moveTo(x, by); ctx.lineTo(x + side*bLen, by - bLen*0.5); ctx.stroke();
    // Sub-branches
    ctx.lineWidth = size * 0.018;
    ctx.beginPath(); ctx.moveTo(x + side*bLen, by - bLen*0.5);
    ctx.lineTo(x + side*(bLen+bLen*0.4), by - bLen*0.7); ctx.stroke();
  }
  // Eerie glow if colored
  if (colored) {
    ctx.globalAlpha = 0.15; ctx.strokeStyle = '#6633aa'; ctx.lineWidth = size*0.12;
    ctx.beginPath(); ctx.moveTo(x, groundY); ctx.lineTo(x, groundY-h); ctx.stroke();
  }
  ctx.restore();
}

function drawCastle(x, groundY, colored) {
  ctx.save();
  const c1 = colored ? '#c8b0e8' : '#404040', c2 = colored ? '#b090d0' : '#333';
  const c3 = colored ? '#e8d4ff' : '#555', wc = colored ? '#88aaff' : '#666';
  const baseH = 280, baseW = 180;
  // Main body
  ctx.fillStyle = c1; ctx.fillRect(x - baseW/2, groundY - baseH, baseW, baseH);
  // Towers
  [[- baseW/2 - 25, baseH + 50],[ baseW/2 + 25, baseH + 50]].forEach(([tx, th]) => {
    ctx.fillStyle = c2; ctx.fillRect(x + tx, groundY - th, 50, th);
    // Battlements
    ctx.fillStyle = c3;
    for (let m = 0; m < 3; m++) ctx.fillRect(x + tx + m*18, groundY - th - 18, 12, 18);
  });
  ctx.fillStyle = c2;
  for (let m = 0; m < 5; m++) ctx.fillRect(x - baseW/2 + m*38, groundY - baseH - 20, 25, 20);
  // Windows
  ctx.fillStyle = wc;
  for (let row = 0; row < 3; row++)
    for (let col = 0; col < 3; col++) {
      const wx = x - 55 + col*50, wy = groundY - baseH + 40 + row*80;
      ctx.fillRect(wx, wy, 20, 30);
      ctx.beginPath(); ctx.arc(wx+10, wy, 10, Math.PI, 0); ctx.fill();
    }
  // Gate
  ctx.fillStyle = colored ? '#4a2a00' : '#222';
  ctx.fillRect(x - 22, groundY - 60, 44, 60);
  ctx.beginPath(); ctx.arc(x, groundY - 60, 22, Math.PI, 0); ctx.fill();
  // Flag
  if (colored) {
    ctx.strokeStyle = '#8844aa'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(x, groundY - baseH - 20); ctx.lineTo(x, groundY - baseH - 60); ctx.stroke();
    ctx.fillStyle = '#ff4488';
    ctx.beginPath(); ctx.moveTo(x, groundY - baseH - 60); ctx.lineTo(x + 30, groundY - baseH - 50); ctx.lineTo(x, groundY - baseH - 40); ctx.fill();
  }
  ctx.restore();
}

function drawHill(x, groundY, size, colored) {
  ctx.save();
  ctx.fillStyle = colored ? '#3a6a20' : '#2a2a2a';
  ctx.beginPath(); ctx.arc(x, groundY + size*0.1, size, Math.PI, 0); ctx.fill();
  if (colored) {
    ctx.fillStyle = '#4a8830';
    ctx.beginPath(); ctx.arc(x - size*0.2, groundY - size*0.4, size*0.4, Math.PI, 0); ctx.fill();
  }
  ctx.restore();
}

function drawBgCrystal(x, groundY, size, colored, seed) {
  ctx.save();
  const hue = (seed * 40) % 360;
  ctx.fillStyle = colored ? `hsla(${hue},80%,65%,0.7)` : 'rgba(100,100,120,0.5)';
  if (colored) { ctx.shadowColor = `hsl(${hue},100%,70%)`; ctx.shadowBlur = 20; }
  ctx.beginPath();
  ctx.moveTo(x, groundY - size);
  ctx.lineTo(x - size*0.25, groundY - size*0.4);
  ctx.lineTo(x - size*0.15, groundY);
  ctx.lineTo(x + size*0.15, groundY);
  ctx.lineTo(x + size*0.25, groundY - size*0.4);
  ctx.closePath(); ctx.fill();
  ctx.fillStyle = colored ? `hsla(${hue},90%,85%,0.6)` : 'rgba(150,150,160,0.4)';
  ctx.beginPath();
  ctx.moveTo(x, groundY - size);
  ctx.lineTo(x - size*0.08, groundY - size*0.4);
  ctx.lineTo(x + size*0.08, groundY - size*0.4);
  ctx.closePath(); ctx.fill();
  ctx.restore();
}

function drawBat(x, y, size, colored, t) {
  ctx.save();
  ctx.fillStyle = colored ? '#220022' : '#333';
  const flap = Math.sin(t * 8) * 0.4;
  ctx.save(); ctx.translate(x, y); ctx.rotate(flap);
  ctx.beginPath(); ctx.ellipse(-size*0.5, 0, size*0.55, size*0.25, -0.3, 0, Math.PI*2); ctx.fill();
  ctx.restore();
  ctx.save(); ctx.translate(x, y); ctx.rotate(-flap);
  ctx.beginPath(); ctx.ellipse(size*0.5, 0, size*0.55, size*0.25, 0.3, 0, Math.PI*2); ctx.fill();
  ctx.restore();
  ctx.fillStyle = colored ? '#330033' : '#444';
  ctx.beginPath(); ctx.ellipse(x, y, size*0.25, size*0.2, 0, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

// ===================== DRAW GROUND =====================
function drawGround() {
  const zone = currentZone, z = ZONES[zone];
  const zn = ZONES[Math.min(zone+1, ZONES.length-1)];
  const nextDist = zone < ZONES.length-1 ? ZONES[zone+1].dist : Infinity;
  const subT = Math.min((distance - z.dist) / Math.max(1, nextDist - z.dist), 1);

  // Grayscale ground for unvisited (right side), colorized for visited (left)
  const colorGround = zone < ZONES.length-1 ? lerpHex(z.groundMain, zn.groundMain, subT) : z.groundMain;
  const grayGround = '#282828';

  ctx.fillStyle = grayGround; ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y);
  if (PONY_X > 0) {
    ctx.fillStyle = colorGround; ctx.fillRect(0, GROUND_Y, PONY_X, H - GROUND_Y);
  }

  // Ground top line
  ctx.strokeStyle = 'rgba(0,0,0,0.4)'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(0, GROUND_Y); ctx.lineTo(W, GROUND_Y); ctx.stroke();

  // Texture marks
  for (let i = 0; i < 8; i++) {
    const lx = ((scrollX * 0.9 + i * 115) % W);
    const col = lx < PONY_X ? 'rgba(255,255,255,0.06)' : 'rgba(255,255,255,0.03)';
    ctx.strokeStyle = col; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(lx, GROUND_Y+5); ctx.lineTo(lx+55, GROUND_Y+5); ctx.stroke();
  }
}

// ===================== DRAW RAINBOW DRESS TRAIL =====================
function drawRainbowTrail() {
  if (trailPoints.length < 4) return;

  const n = trailPoints.length;
  const bandCount = RAINBOW_COLORS.length;
  const bandH = 10;
  const totalH = bandCount * bandH; // ~60px total ribbon height

  // Convert stored world-x to current screen-x
  const pts = trailPoints.map(p => ({ x: p.wx - scrollX, y: p.y }));

  const anchorX = pts[n - 1].x;  // newest = pony position on screen
  const anchorY = pts[n - 1].y;
  const tailX   = pts[0].x;      // oldest = leftmost on screen

  for (let b = 0; b < bandCount; b++) {
    // Fixed vertical lanes ‚Äî purely horizontal bands like a flag
    const yTop = anchorY - totalH + b * bandH;
    const yBot = yTop + bandH;

    ctx.beginPath();
    ctx.moveTo(tailX, yTop);

    // Top edge left‚Üíright: tiny 2px undulation for life
    for (let i = 0; i < n; i++) {
      const wave = Math.sin(time * 2.5 + i * 0.07 + b * 0.55) * 2;
      ctx.lineTo(pts[i].x, yTop + wave);
    }
    // Bottom edge right‚Üíleft
    for (let i = n - 1; i >= 0; i--) {
      const wave = Math.sin(time * 2.5 + i * 0.07 + b * 0.55 + 0.35) * 2;
      ctx.lineTo(pts[i].x, yBot + wave);
    }
    ctx.closePath();

    // Fade: transparent at tail tip ‚Üí fully opaque near pony
    const grad = ctx.createLinearGradient(tailX, 0, anchorX, 0);
    grad.addColorStop(0,    RAINBOW_COLORS[b] + '00');
    grad.addColorStop(0.06, RAINBOW_COLORS[b] + 'aa');
    grad.addColorStop(0.18, RAINBOW_COLORS[b] + 'ff');
    grad.addColorStop(1,    RAINBOW_COLORS[b] + 'ff');
    ctx.fillStyle = grad;
    ctx.fill();
  }

  // Sparkle glow at the pony end of the trail
  ctx.save();
  ctx.globalAlpha = 0.6 + Math.sin(time * 9) * 0.2;
  const midY = anchorY - totalH / 2;
  const glow = ctx.createRadialGradient(anchorX, midY, 0, anchorX, midY, 55);
  glow.addColorStop(0,    'rgba(255,255,255,0.9)');
  glow.addColorStop(0.45, 'rgba(255,210,80,0.35)');
  glow.addColorStop(1,    'rgba(255,255,255,0)');
  ctx.fillStyle = glow;
  ctx.beginPath(); ctx.arc(anchorX, midY, 55, 0, Math.PI * 2); ctx.fill();
  ctx.restore();
}


// ===================== DRAW PONY =====================
function drawPony(x, y, pony, dying, rainbowMode, t) {
  const { body, mane, mane2, tail } = pony;
  ctx.save();
  ctx.translate(x, y);

  const bW = 40, bH = 24, legH = 18;
  const legSwing = dying ? 0 : Math.sin(t * 11) * 6;

  // ---- LONG FLOWING TAIL ----
  if (rainbowMode && !dying) {
    for (let s = 0; s < RAINBOW_COLORS.length; s++) {
      ctx.strokeStyle = RAINBOW_COLORS[s];
      ctx.lineWidth = 5 - s*0.4;
      ctx.lineCap = 'round';
      const wave = Math.sin(t*5 + s*0.4) * 12;
      const wave2 = Math.sin(t*3 + s*0.7) * 8;
      ctx.beginPath();
      ctx.moveTo(-bW/2 + 2, bH/2 - 2 - s*1.5);
      ctx.bezierCurveTo(
        -bW/2 - 20 + wave, bH/2 + 15 - s*2,
        -bW/2 - 55 + wave2, bH/2 + 25 + s*3,
        -bW/2 - 90 + wave, bH/2 + 10 + s*4
      );
      ctx.stroke();
    }
  } else {
    // Long flowing regular tail
    const wave = Math.sin(t * 3) * 10;
    const wave2 = Math.sin(t * 2.2 + 1) * 8;
    const tc = dying ? '#555' : tail;
    const tc2 = dying ? '#444' : mane2;
    [tc, tc2].forEach((c, i) => {
      ctx.strokeStyle = c; ctx.lineWidth = 8 - i*2; ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(-bW/2 + 2, bH/2 - 2 - i*3);
      ctx.bezierCurveTo(
        -bW/2 - 18 + wave + i*3, bH/2 + 18 - i*2,
        -bW/2 - 50 + wave2 + i*2, bH/2 + 28 + i*4,
        -bW/2 - 82 + wave + i*3, bH/2 + 14 + i*5
      );
      ctx.stroke();
    });
  }

  // ---- LEGS ----
  ctx.strokeStyle = dying ? '#666' : body; ctx.lineWidth = 6; ctx.lineCap = 'round';
  [[-bW/2+10, legSwing], [-bW/2+18, -legSwing], [bW/2-18, legSwing], [bW/2-10, -legSwing]].forEach(([lx, lo]) => {
    ctx.beginPath(); ctx.moveTo(lx, bH/2-2); ctx.lineTo(lx + lo*0.4, bH/2 + legH); ctx.stroke();
  });

  // ---- BODY ----
  ctx.fillStyle = dying ? '#888' : body;
  ctx.beginPath(); ctx.roundRect(-bW/2, -bH/2, bW, bH, 10); ctx.fill();

  // ---- NECK ----
  ctx.fillStyle = dying ? '#888' : body;
  ctx.beginPath(); ctx.roundRect(bW/2-10, -bH/2-12, 14, 18, 5); ctx.fill();

  // ---- HEAD ----
  ctx.beginPath(); ctx.ellipse(bW/2+10, -bH/2-8, 14, 11, 0.25, 0, Math.PI*2); ctx.fill();

  // Snout
  ctx.fillStyle = dying ? '#777' : lerpHex(body, '#fff', 0.3);
  ctx.beginPath(); ctx.ellipse(bW/2+20, -bH/2-5, 6, 5, 0.1, 0, Math.PI*2); ctx.fill();
  // Nostrils
  ctx.fillStyle = dying ? '#555' : lerpHex(body, '#000', 0.4);
  ctx.beginPath(); ctx.arc(bW/2+18, -bH/2-4, 1.5, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(bW/2+22, -bH/2-4, 1.5, 0, Math.PI*2); ctx.fill();

  // ---- EYE ----
  if (dying) {
    ctx.strokeStyle = '#333'; ctx.lineWidth = 2.5;
    ctx.beginPath(); ctx.moveTo(bW/2+6, -bH/2-12); ctx.lineTo(bW/2+12, -bH/2-7); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(bW/2+12, -bH/2-12); ctx.lineTo(bW/2+6, -bH/2-7); ctx.stroke();
    // tear
    ctx.strokeStyle = '#88aaff'; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(bW/2+9, -bH/2-7); ctx.lineTo(bW/2+8, -bH/2-1); ctx.stroke();
  } else {
    ctx.fillStyle = '#111';
    ctx.beginPath(); ctx.ellipse(bW/2+14, -bH/2-10, 4, 5, -0.1, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = 'white';
    ctx.beginPath(); ctx.arc(bW/2+15.5, -bH/2-11.5, 1.5, 0, Math.PI*2); ctx.fill();
    // Eyelash
    ctx.strokeStyle = '#111'; ctx.lineWidth = 1.2;
    for (let e = 0; e < 3; e++) {
      ctx.beginPath();
      ctx.moveTo(bW/2+11+e*1.8, -bH/2-14);
      ctx.lineTo(bW/2+10+e*2.2, -bH/2-18);
      ctx.stroke();
    }
  }

  // ---- EAR ----
  ctx.fillStyle = dying ? '#777' : body;
  ctx.beginPath();
  const ex = bW/2 + 4, ey = -bH/2 - 17;
  ctx.moveTo(ex, dying ? ey+8 : ey);
  ctx.lineTo(ex - 6, dying ? ey+16 : ey+10);
  ctx.lineTo(ex + 6, ey + 10);
  ctx.closePath(); ctx.fill();
  ctx.fillStyle = dying ? '#555' : mane;
  ctx.beginPath(); ctx.moveTo(ex, dying ? ey+9 : ey+1); ctx.lineTo(ex-3, dying ? ey+14 : ey+9); ctx.lineTo(ex+4, ey+9); ctx.closePath(); ctx.fill();

  // ---- LONG FLOWING MANE ----
  // Eye is at approx (bW/2+14, -bH/2-10).
  // Mane starts just above the eye: (bW/2+12, -bH/2-18), flows backward and down.
  if (rainbowMode && !dying) {
    RAINBOW_COLORS.forEach((c, s) => {
      ctx.strokeStyle = c; ctx.lineWidth = 5 - s*0.4; ctx.lineCap = 'round';
      const flow = Math.sin(t*4 + s*0.5) * 10;
      const flow2 = Math.sin(t*3 + s*0.8) * 8;
      // Start right above the eye, stagger each strand slightly
      const startX = bW/2 + 12 - s*0.8;
      const startY = -bH/2 - 17 + s*1.2;
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      // Sweep back over the head, then down over neck
      ctx.bezierCurveTo(
        startX - 10 + flow,  startY - 4,
        bW/2 - 4 + flow2,    -bH/2 - 14 - s,
        bW/2 - 20 + flow,    -bH/2 - 4 - s
      );
      ctx.bezierCurveTo(
        bW/2 - 34 + flow2,   bH/2 + 4 + s*2,
        bW/2 - 32 + flow,    bH/2 + 18 + s*3,
        bW/2 - 22 + flow2,   bH/2 + 34 + s*3
      );
      ctx.stroke();
    });
  } else {
    // Long flowing regular mane ‚Äî starts just above the eye
    const flowA = Math.sin(t*3) * 8, flowB = Math.sin(t*2.5 + 0.8) * 6;
    [mane, mane2].forEach((mc, mi) => {
      ctx.strokeStyle = dying ? '#555' : mc;
      ctx.lineWidth = mi === 0 ? 10 : 7; ctx.lineCap = 'round';
      const off = mi * 1.5;
      // Start above the eye
      const startX = bW/2 + 13 - mi*2;
      const startY = -bH/2 - 17 + mi*2;
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      // Sweep back over head, down neck, drape to ground
      ctx.bezierCurveTo(
        startX - 10 + flowA,      startY - 5,
        bW/2 - 2 + flowB + off,   -bH/2 - 16,
        bW/2 - 18 + flowA + off,  -bH/2 - 6
      );
      ctx.bezierCurveTo(
        bW/2 - 34 + flowB + off,  bH/2 + 6,
        bW/2 - 32 + flowA + off,  bH/2 + 22,
        bW/2 - 22 + flowB + off,  bH/2 + 38
      );
      ctx.bezierCurveTo(
        bW/2 - 14 + flowA + off,  bH/2 + 46,
        bW/2 - 8 + flowB + off,   bH/2 + 40,
        bW/2 - 4 + flowA + off,   bH/2 + 28
      );
      ctx.stroke();
    });
  }

  ctx.restore();
}

// ===================== DRAW THORNY BUSH OBSTACLE =====================
function drawObstacle(obs) {
  const { x, y, w, h } = obs;
  ctx.save();

  // Ground color of the bush depends on zone/color reveal
  // Obstacles are always at ground level, their world X is their screen X + scrollX
  const worldX = obs.x + scrollX;
  const colored = isColorized(worldX);

  const leafCol = colored ? '#2d7a18' : '#333';
  const leafCol2 = colored ? '#3a9a22' : '#3d3d3d';
  const thornCol = colored ? '#1a0a00' : '#222';

  // Bush body (layered circles for bushy look)
  const bushCX = x + w/2, bushBY = y + h;
  const rx = w/2, ry = h * 0.6;

  // Shadow base
  ctx.fillStyle = colored ? 'rgba(0,0,0,0.25)' : 'rgba(0,0,0,0.4)';
  ctx.beginPath(); ctx.ellipse(bushCX, bushBY, rx*1.1, 5, 0, 0, Math.PI*2); ctx.fill();

  // Multiple overlapping circles to form bush silhouette
  const circles = [
    [bushCX, bushBY - h*0.35, rx*0.8, ry*0.8],
    [bushCX - w*0.28, bushBY - h*0.28, rx*0.65, ry*0.65],
    [bushCX + w*0.28, bushBY - h*0.28, rx*0.65, ry*0.65],
    [bushCX - w*0.12, bushBY - h*0.6, rx*0.55, ry*0.55],
    [bushCX + w*0.18, bushBY - h*0.55, rx*0.5, ry*0.5],
    [bushCX, bushBY - h*0.75, rx*0.45, ry*0.45],
  ];
  circles.forEach(([cx,cy,crx,cry], i) => {
    ctx.fillStyle = i % 2 === 0 ? leafCol : leafCol2;
    ctx.beginPath(); ctx.ellipse(cx, cy, crx, cry, 0, 0, Math.PI*2); ctx.fill();
  });

  // Thorns poking outward from bush edges
  ctx.fillStyle = thornCol;
  ctx.strokeStyle = thornCol; ctx.lineWidth = 1.5;

  // Thorns all around the silhouette
  const thornPositions = [
    [bushCX - rx*0.85, bushBY - h*0.3, -0.8],
    [bushCX + rx*0.85, bushBY - h*0.3, 0.8],
    [bushCX - rx*0.65, bushBY - h*0.65, -1.2],
    [bushCX + rx*0.65, bushBY - h*0.65, 1.2],
    [bushCX - rx*0.25, bushBY - h*0.88, -Math.PI/2 + 0.3],
    [bushCX + rx*0.25, bushBY - h*0.88, -Math.PI/2 - 0.3],
    [bushCX, bushBY - h*0.95, -Math.PI/2],
    [bushCX - rx*0.5, bushBY - h*0.15, -0.5],
    [bushCX + rx*0.5, bushBY - h*0.15, 0.5],
  ];
  thornPositions.forEach(([tx,ty,angle]) => {
    const tLen = 9 + (colored ? 2 : 0);
    ctx.beginPath();
    ctx.moveTo(tx, ty);
    ctx.lineTo(tx + Math.cos(angle)*tLen, ty + Math.sin(angle)*tLen);
    ctx.lineTo(tx + Math.cos(angle+0.35)*tLen*0.45, ty + Math.sin(angle+0.35)*tLen*0.45);
    ctx.closePath(); ctx.fill();
  });

  // Dark inner shadow for depth
  ctx.fillStyle = colored ? 'rgba(0,30,0,0.25)' : 'rgba(0,0,0,0.3)';
  ctx.beginPath(); ctx.ellipse(bushCX, bushBY - h*0.4, rx*0.5, ry*0.5, 0, 0, Math.PI*2); ctx.fill();

  // Red danger outline ‚Äî draw around the overall bush silhouette
  ctx.strokeStyle = '#dd1111';
  ctx.lineWidth = 2.5;
  ctx.shadowColor = '#ff0000';
  ctx.shadowBlur = 8;
  circles.forEach(([cx,cy,crx,cry]) => {
    ctx.beginPath(); ctx.ellipse(cx, cy, crx + 2, cry + 2, 0, 0, Math.PI*2); ctx.stroke();
  });
  ctx.shadowBlur = 0;

  ctx.restore();
}

// ===================== DRAW PLATFORM =====================
function drawPlatform(plat) {
  const { x, y, w, h } = plat;
  const worldX = plat.x + scrollX;
  const colored = isColorized(worldX);

  ctx.save();
  ctx.fillStyle = colored ? '#3d2008' : '#303030';
  ctx.beginPath(); ctx.roundRect(x, y, w, h, 4); ctx.fill();
  // Mossy top
  ctx.fillStyle = colored ? '#2a6a10' : '#3a3a3a';
  ctx.beginPath(); ctx.roundRect(x, y, w, h/2, [4,4,0,0]); ctx.fill();
  // Grass tufts
  if (colored) {
    ctx.fillStyle = '#3a8820';
    for (let gx = x + 8; gx < x + w - 8; gx += 14) {
      ctx.beginPath(); ctx.arc(gx, y, 4, Math.PI, 0); ctx.fill();
    }
  }
  ctx.restore();
}

// ===================== DRAW POWERUP =====================
function drawPowerup(pu) {
  const { x, y, type, angle } = pu;
  ctx.save(); ctx.translate(x, y); ctx.rotate(angle);

  if (type === 'rainbow') {
    const bob = Math.sin(time*4) * 3;
    ctx.translate(0, bob);
    ctx.shadowBlur = 20; ctx.shadowColor = 'white';
    // Outer glow ring
    for (let r = 0; r < RAINBOW_COLORS.length; r++) {
      ctx.strokeStyle = RAINBOW_COLORS[r]; ctx.lineWidth = 4;
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.arc(0, 0, 16 + r*1.5, (r/RAINBOW_COLORS.length)*Math.PI*2, (r+1)/RAINBOW_COLORS.length*Math.PI*2);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
    // Center white
    ctx.fillStyle = 'white'; ctx.shadowBlur = 10;
    ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#ffcc00'; ctx.font = 'bold 9px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('‚òÖ', 0, 0);
  } else {
    // Shield power-up
    const bob = Math.sin(time*3 + 1) * 3;
    ctx.translate(0, bob);
    ctx.shadowColor = '#88ddff'; ctx.shadowBlur = 18;
    ctx.fillStyle = 'rgba(80,180,255,0.85)';
    ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, -18); ctx.lineTo(15, -8); ctx.lineTo(15, 5);
    ctx.lineTo(0, 19); ctx.lineTo(-15, 5); ctx.lineTo(-15, -8);
    ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.fillStyle = 'white'; ctx.font = 'bold 13px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText('‚ú¶', 0, 0);
  }
  ctx.restore();
}

// ===================== DRAW PARTICLES =====================
function drawParticles() {
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.r * p.life, 0, Math.PI*2); ctx.fill();
  });
  ctx.globalAlpha = 1;
}

// ===================== DRAW SHIELD =====================
function drawShieldEffect() {
  if (!shieldMode) return;
  ctx.save();
  ctx.globalAlpha = 0.25 + Math.sin(time*8)*0.1;
  ctx.strokeStyle = '#88ddff'; ctx.lineWidth = 4;
  ctx.shadowColor = '#88ddff'; ctx.shadowBlur = 24;
  ctx.beginPath(); ctx.arc(PONY_X, ponyY, 42, 0, Math.PI*2); ctx.stroke();
  ctx.globalAlpha = 0.07;
  ctx.fillStyle = '#88ddff';
  ctx.beginPath(); ctx.arc(PONY_X, ponyY, 42, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

// ===================== SPAWN =====================
function spawnObstacle() {
  const h = 38 + Math.random() * 36, w = 35 + Math.random() * 30;
  obstacles.push({ x: W + 60, y: GROUND_Y - h + 8, w, h });
}
function spawnPlatform() {
  const y = GROUND_Y - 110 - Math.random() * 120;
  platforms.push({ x: W + 60, y, w: 80 + Math.random() * 70, h: 14 });
}
function spawnPowerup(type) {
  const y = GROUND_Y - 70 - Math.random() * 110;
  powerups.push({ x: W + 60, y, type, alive: true, angle: 0 });
}

// ===================== COLLISION =====================
function rectRect(ax,ay,aw,ah,bx,by,bw,bh) {
  return ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by;
}

// ===================== DIE =====================
function die() {
  if (dying || shieldMode) return;
  dying = true; deathTimer = 130; playDie(); shake = 28;
  for (let i = 0; i < 22; i++) {
    const a = (Math.PI*2*i/22);
    particles.push({ x:PONY_X, y:ponyY,
      vx:Math.cos(a)*(2+Math.random()*5), vy:Math.sin(a)*(2+Math.random()*5)-2,
      life:1, color:`hsl(${i*16},100%,65%)`, r:5+Math.random()*6 });
  }
}

// ===================== ZONE =====================
function getZone() {
  const CYCLE = 5300; // total distance of one full zone loop
  const loopDist = distance % CYCLE;
  for (let i = ZONES.length-1; i>=0; i--) if (loopDist >= ZONES[i].dist) return i;
  return 0;
}

// ===================== SELECT SCREEN =====================
const grid = document.getElementById('pony-grid');
PONIES.forEach((pony, i) => {
  const card = document.createElement('div');
  card.className = 'pony-card' + (i===0?' selected':'');
  card.innerHTML = `<canvas width="96" height="80"></canvas><span>${pony.name}</span>`;
  const c = card.querySelector('canvas');
  // Draw mini pony
  const mc = c.getContext('2d');
  mc.clearRect(0,0,96,80);
  mc.save(); mc.translate(48, 52);
  // mini draw (simplified)
  const { body, mane, mane2, tail } = pony;
  // tail
  mc.strokeStyle = tail; mc.lineWidth = 5; mc.lineCap = 'round';
  mc.beginPath(); mc.moveTo(-18, 8); mc.bezierCurveTo(-28, 18, -42, 22, -38, 12); mc.stroke();
  mc.strokeStyle = mane2; mc.lineWidth = 3;
  mc.beginPath(); mc.moveTo(-18, 6); mc.bezierCurveTo(-30, 16, -44, 18, -40, 8); mc.stroke();
  // body
  mc.fillStyle = body; mc.beginPath(); mc.roundRect(-16, -10, 32, 20, 8); mc.fill();
  // neck+head
  mc.fillStyle = body; mc.beginPath(); mc.roundRect(12, -18, 10, 14, 4); mc.fill();
  mc.beginPath(); mc.ellipse(24, -14, 11, 9, 0.2, 0, Math.PI*2); mc.fill();
  // eye
  mc.fillStyle = '#111'; mc.beginPath(); mc.arc(28, -16, 3, 0, Math.PI*2); mc.fill();
  mc.fillStyle = 'white'; mc.beginPath(); mc.arc(29, -17, 1, 0, Math.PI*2); mc.fill();
  // mane ‚Äî starts right above the eye (eye at ~28,-16), sweeps back and down
  mc.strokeStyle = mane; mc.lineWidth = 6; mc.lineCap = 'round';
  mc.beginPath(); mc.moveTo(26,-23); mc.bezierCurveTo(20,-28,8,-28,-2,-22); mc.bezierCurveTo(-12,-15,-12,4,-6,18); mc.stroke();
  mc.strokeStyle = mane2; mc.lineWidth = 3;
  mc.beginPath(); mc.moveTo(27,-22); mc.bezierCurveTo(18,-27,6,-26,-4,-20); mc.bezierCurveTo(-14,-13,-12,6,-6,20); mc.stroke();
  // legs
  mc.strokeStyle = body; mc.lineWidth = 5; mc.lineCap = 'round';
  [[-10,10],[0,10],[14,10],[20,10]].forEach(([lx,ly]) => { mc.beginPath(); mc.moveTo(lx,ly); mc.lineTo(lx, ly+14); mc.stroke(); });
  mc.restore();

  card.addEventListener('click', () => {
    document.querySelectorAll('.pony-card').forEach(cc => cc.classList.remove('selected'));
    card.classList.add('selected'); selectedPony = i;
  });
  grid.appendChild(card);
});

document.getElementById('start-btn').addEventListener('click', startGame);
document.getElementById('restart-btn').addEventListener('click', () => {
  document.getElementById('gameover-screen').style.display = 'none'; startGame();
});

// ===================== START =====================
function startGame() {
  document.getElementById('select-screen').style.display = 'none';
  document.getElementById('gameover-screen').style.display = 'none';
  gameState = 'playing';
  score = 0; distance = 0; gameSpeed = 6;
  ponyY = GROUND_Y; ponyVY = 0; onGround = true; jumpCount = 0;
  dying = false; deathTimer = 0;
  rainbowMode = false; rainbowTimer = 0; shieldMode = false; shieldTimer = 0;
  shake = 0; shakeX = 0; shakeY = 0;
  trailPoints = []; particles = []; obstacles = []; platforms = []; powerups = [];
  scrollX = 0; time = 0; currentZone = 0;
  spawnTimer = 60; platformTimer = 120; powerupTimer = 220;
  initBgObjects();
  document.getElementById('score').textContent = '0';
  document.getElementById('zone-label').textContent = ZONES[0].name;
  document.getElementById('rainbow-indicator').classList.remove('active');
  document.getElementById('shield-indicator').classList.remove('active');
}

// ===================== INPUT =====================
document.addEventListener('keydown', e => { if (e.code==='Space') { e.preventDefault(); handleJump(); } });
canvas.addEventListener('click', handleJump);

function handleJump() {
  if (gameState !== 'playing' || dying) return;
  if (jumpCount < MAX_JUMPS || rainbowMode) {
    ponyVY = JUMP_FORCE * (rainbowMode ? 0.72 : 1);
    onGround = false; jumpCount++;
    playJump();
    for (let i = 0; i < 8; i++) {
      particles.push({ x:PONY_X, y:ponyY+18,
        vx:(Math.random()-0.5)*5, vy:2+Math.random()*3,
        life:1, color:`hsl(${Math.random()*360},100%,70%)`, r:4 });
    }
  }
}

// ===================== MAIN LOOP =====================
let lastTime = 0;
function loop(ts) {
  const dt = Math.min((ts - lastTime) / 16.67, 3);
  lastTime = ts;

  if (gameState !== 'playing') { requestAnimationFrame(loop); return; }

  time += 0.016 * dt;

  // Shake
  if (shake > 0) {
    shake -= dt * 1.6;
    shakeX = (Math.random()-0.5)*shake*1.5;
    shakeY = (Math.random()-0.5)*shake*1.5;
  } else { shakeX=0; shakeY=0; shake=0; }

  // Zone
  const newZone = getZone();
  if (newZone !== currentZone) {
    currentZone = newZone;
    document.getElementById('zone-label').textContent = ZONES[currentZone].name;
  }

  ctx.save();
  ctx.translate(shakeX, shakeY);

  // --- UPDATE ---
  const speed = gameSpeed * dt * (rainbowMode ? 1.65 : 1);

  // Move world (always, so the game keeps scrolling during death animation)
  obstacles.forEach(o => o.x -= speed);
  platforms.forEach(p => p.x -= speed);
  powerups.forEach(pu => { pu.x -= speed; pu.angle += 0.04*dt; });
  scrollX += speed;

  obstacles = obstacles.filter(o => o.x > -120);
  platforms = platforms.filter(p => p.x > -220);
  powerups = powerups.filter(pu => pu.x > -60);

  // Particles always animate so death explosion plays out
  particles.forEach(p => { p.x+=p.vx*dt; p.y+=p.vy*dt; p.vy+=0.18*dt; p.life-=0.028*dt; });
  particles = particles.filter(p => p.life > 0);

  if (!dying) {
    // Physics
    ponyVY += GRAVITY * dt;
    ponyY += ponyVY * dt;
    if (ponyY >= GROUND_Y) { ponyY = GROUND_Y; ponyVY = 0; if (!onGround) { onGround=true; jumpCount=0; } }

    // Platform collision
    platforms.forEach(plat => {
      if (PONY_X+22>plat.x && PONY_X-22<plat.x+plat.w && ponyY>plat.y-2 && ponyY<plat.y+14 && ponyVY>0) {
        ponyY=plat.y; ponyVY=0; onGround=true; jumpCount=0;
      }
    });

    // Trail: store world-x so points spread out horizontally as pony runs
    trailPoints.push({ wx: scrollX + PONY_X - 22, y: ponyY });
    if (trailPoints.length > 120) trailPoints.shift();

    // Spawn
    spawnTimer -= dt; if (spawnTimer <= 0) { spawnObstacle(); spawnTimer = 55 + Math.random()*75; }
    platformTimer -= dt; if (platformTimer <= 0) { spawnPlatform(); platformTimer = 95 + Math.random()*115; }
    powerupTimer -= dt; if (powerupTimer <= 0) { spawnPowerup(Math.random()<0.5?'rainbow':'shield'); powerupTimer = 180 + Math.random()*200; }

    // Collisions
    obstacles.forEach(obs => {
      if (!shieldMode && rectRect(PONY_X-20, ponyY-24, 38, 40, obs.x+6, obs.y+6, obs.w-12, obs.h-6)) die();
    });

    // Powerups
    powerups.forEach(pu => {
      if (pu.alive && rectRect(PONY_X-20, ponyY-24, 38, 40, pu.x-18, pu.y-18, 36, 36)) {
        pu.alive = false; playPowerup();
        if (pu.type === 'rainbow') {
          rainbowMode=true; rainbowTimer=300;
          document.getElementById('rainbow-indicator').classList.add('active');
          for (let i=0;i<24;i++) {
            const a=Math.random()*Math.PI*2;
            particles.push({ x:PONY_X, y:ponyY, vx:Math.cos(a)*6, vy:Math.sin(a)*6-2, life:1, color:`hsl(${i*15},100%,60%)`, r:7 });
          }
        } else {
          shieldMode=true; shieldTimer=420; playShield();
          document.getElementById('shield-indicator').classList.add('active');
        }
      }
    });
    powerups = powerups.filter(pu => pu.alive);

    // Powerup timers
    if (rainbowMode) { rainbowTimer-=dt; if (rainbowTimer<=0) { rainbowMode=false; document.getElementById('rainbow-indicator').classList.remove('active'); } }
    if (shieldMode) { shieldTimer-=dt; if (shieldTimer<=0) { shieldMode=false; document.getElementById('shield-indicator').classList.remove('active'); } }

    // Score
    distance += speed * 0.5;
    score = Math.floor(distance);
    document.getElementById('score').textContent = score;
    gameSpeed = 6 + distance / 2200;
  }

  // --- DRAW ---
  drawBackground();
  drawGround();
  drawRainbowTrail();
  platforms.forEach(drawPlatform);
  obstacles.forEach(drawObstacle);
  powerups.forEach(drawPowerup);
  drawParticles();
  drawShieldEffect();
  drawPony(PONY_X, ponyY, PONIES[selectedPony], dying, rainbowMode, time);

  // Death: fade to grayscale overlay
  if (dying) {
    const fadeIn = Math.min(1, (130 - deathTimer) / 65);
    if (fadeIn > 0.01) {
      // Desaturate via pixel manipulation is expensive; instead overlay dark semi-transparent
      ctx.save();
      ctx.globalAlpha = fadeIn * 0.7;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);
      // White vignette text hint
      ctx.globalAlpha = fadeIn * 0.5;
      ctx.fillStyle = '#fff';
      ctx.font = "bold 14px 'Nunito',sans-serif";
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.restore();
    }
    deathTimer -= dt;
    if (deathTimer <= 0) {
      document.getElementById('final-score').textContent = `Score: ${score}`;
      document.getElementById('gameover-screen').style.display = 'flex';
      gameState = 'dead';
    }
  }

  ctx.restore();
  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
</script>
</body>
</html>
